<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>src.viz API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.viz</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import pickle as pkl
import sys
sys.path.append(&#39;..&#39;)
import config
import data
from os.path import join as oj
import matplotlib.gridspec as grd
import numpy as np
import pandas as pd
import seaborn as sns
from matplotlib import pyplot as plt
from matplotlib_venn import venn2
from sklearn import decomposition
from sklearn import metrics
from sklearn.covariance import EllipticEnvelope
from sklearn.ensemble import IsolationForest
from sklearn.neighbors import LocalOutlierFactor
from sklearn.svm import OneClassSVM
from sklearn.utils.multiclass import unique_labels
import os
import matplotlib.ticker as mtick
from config import DIR_FIGS
from matplotlib.colors import LinearSegmentedColormap
from matplotlib import cm
from matplotlib.colors import ListedColormap
# DIR_FILE = os.path.dirname(os.path.realpath(__file__)) # directory of this file
# DIR_FIGS = oj(DIR_FILE, &#39;../reports/figs&#39;)
try:
    from skimage.external.tifffile import imread
except:
    from skimage.io import imread


cb2 = &#39;#66ccff&#39;
cb = &#39;#1f77b4&#39;
co = &#39;#ff7f0e&#39;
cr = &#39;#cc0000&#39;
cp = &#39;#cc3399&#39;
cy = &#39;#d8b365&#39;
cg = &#39;#5ab4ac&#39;
cmap = LinearSegmentedColormap.from_list(
    name=&#39;orange-blue&#39;, 
    colors=[(205/255, 85/255, 51/255),
            &#39;lightgray&#39;,
            (50/255, 129/255, 168/255)]
)

def savefig(s: str, png=False):
#     plt.tight_layout()
    plt.savefig(oj(DIR_FIGS, &#39;fig_&#39; + s + &#39;.pdf&#39;), bbox_inches=&#39;tight&#39;)
    if png:
        plt.savefig(oj(DIR_FIGS, &#39;fig_&#39; + s + &#39;.png&#39;), dpi=300, bbox_inches=&#39;tight&#39;)
    

def fix_feat_name(s):
    return s.replace(&#39;_&#39;, &#39; &#39;).replace(&#39;X&#39;, &#39;Clath&#39;).capitalize()

def plot_confusion_matrix(y_true, y_pred, classes,
                          normalize=False,
                          title=None,
                          cmap=plt.cm.Blues):
    &#34;&#34;&#34;
    This function prints and plots the confusion matrix.
    Normalization can be applied by setting `normalize=True`.
    Params
    ------
    classes: np.ndarray(Str)
        classes=np.array([&#39;aux-&#39;, &#39;aux+&#39;])
    &#34;&#34;&#34;
    plt.figure(dpi=300)
    if not title:
        if normalize:
            title = &#39;Normalized confusion matrix&#39;
        else:
            title = &#39;Confusion matrix, without normalization&#39;

    # Compute confusion matrix
    cm = metrics.confusion_matrix(y_true, y_pred)
    # Only use the labels that appear in the data
    classes = classes[unique_labels(y_true.astype(np.int), y_pred.astype(np.int))]
    if normalize:
        cm = cm.astype(&#39;float&#39;) / cm.sum(axis=1)[:, np.newaxis]

    #     fig, ax = plt.subplots()
    im = plt.imshow(cm, interpolation=&#39;nearest&#39;, cmap=cmap)
    ax = plt.gca()
    #     ax.figure.colorbar(im, ax=ax)
    # We want to show all ticks...
    ax.set(xticks=np.arange(cm.shape[1]),
           yticks=np.arange(cm.shape[0]),
           # ... and label them with the respective list entries
           xticklabels=classes, yticklabels=classes,
           #            title=title,
           ylabel=&#39;True label&#39;,
           xlabel=&#39;Predicted label&#39;)

    # Rotate the tick labels and set their alignment.
    plt.setp(ax.get_xticklabels(), rotation=45, ha=&#34;right&#34;,
             rotation_mode=&#34;anchor&#34;)

    # Loop over data dimensions and create text annotations.
    fmt = &#39;.2f&#39; if normalize else &#39;d&#39;
    thresh = cm.max() / 2.
    for i in range(cm.shape[0]):
        for j in range(cm.shape[1]):
            ax.text(j, i, format(cm[i, j], fmt),
                    ha=&#34;center&#34;, va=&#34;center&#34;,
                    color=&#34;white&#34; if cm[i, j] &gt; thresh else &#34;black&#34;)
    return ax


def highlight_max(data, color=&#39;#0e5c99&#39;):
    &#39;&#39;&#39;
    highlight the maximum in a Series or DataFrame
    &#39;&#39;&#39;
    attr = &#39;background-color: {}&#39;.format(color)
    if data.ndim == 1:  # Series from .apply(axis=0) or axis=1
        is_max = data == data.max()
        return [attr if v else &#39;&#39; for v in is_max]
    else:  # from .apply(axis=None)
        is_max = data == data.max().max()
        return pd.DataFrame(np.where(is_max, attr, &#39;&#39;),
                            index=data.index, columns=data.columns)


# visualize biggest errs
def viz_biggest_errs(df, idxs_cv, idxs, Y_test, preds, preds_proba,
                     num_to_plot=20,
                     aux_thresh=642,
                     show_track_num=True,
                     show_track_pid=False,
                     sort_by_residuals=True,
                     plot_x=True,
                     plot_y=True,
                     plot_z=False,
                     xlim_constant=True,
                     lifetime_max=None,
                     text_labels=False):
    &#39;&#39;&#39;Visualize X and Y where the top examples are the most wrong / least confident
    Params
    ------
    idxs_cv: integer ndarray
        which idxs are not part of the test set (usually just 0, 1, 2, ...)
    idxs: boolean ndarray
        subset of points to plot
    
    &#39;&#39;&#39;

    
    # deal with idxs
    if idxs is not None:
        Y_test = Y_test[idxs]
        preds = preds[idxs]
        preds_proba = preds_proba[idxs]
        if idxs_cv is None:
            idxs_cv = np.arange(df.shape[0])
        df = df.iloc[idxs_cv][idxs]
    
    # get args to sort by
    if sort_by_residuals:
        residuals = np.abs(Y_test - preds_proba)
        args = np.argsort(residuals)[::-1]
        dft = df.iloc[args]
    else:
        dft = df
    if lifetime_max is None:
        lifetime_max = np.max(dft.lifetime.values)
    if num_to_plot is None:
        num_to_plot = dft.shape[0]
    R = int(np.sqrt(num_to_plot))
    C = num_to_plot // R  # + 1
    plt.figure(figsize=(C * 3, R * 2.5), dpi=200)

    i = 0
    for r in range(R):
        for c in range(C):
            if i &lt; dft.shape[0]:
                row = dft.iloc[i]
                ax = plt.subplot(R, C, i + 1)
                # show nums on tracks
                if show_track_num:
                    ax.text(.5, .9, f&#39;{i}&#39;, # row.pid
                            horizontalalignment=&#39;right&#39;,
                            transform=ax.transAxes)
                elif show_track_pid:
                    ax.text(.5, .9, f&#39;{row.pid}&#39;, # row.pid
                            horizontalalignment=&#39;right&#39;,
                            transform=ax.transAxes)
                plt.axis(&#39;off&#39;)
                
                if plot_x:
                    plt.plot(row[&#34;X&#34;], color=cr, label=&#39;clath&#39;, lw=2) # could do X_extended
                if plot_y:
                    plt.plot(row[&#34;Y&#34;], color=cg, label=&#39;aux&#39;, lw=2)
                if plot_z:
                    plt.plot(row[&#34;Z&#34;], color=&#39;gray&#39;, label=&#39;dyn&#39;)

                if xlim_constant:
                    plt.xlim([-1, lifetime_max])
                plt.axhline(aux_thresh, color=&#39;gray&#39;, alpha=0.5, lw=2)
                i += 1
                
    if text_labels:
        plt.text(len(row[&#34;X&#34;]), row[&#34;X&#34;][-1], &#39;Clathrin&#39;, color=cr, fontsize=25, fontweight=&#39;bold&#39;)
        plt.text(len(row[&#34;Y&#34;]), row[&#34;Y&#34;][-1], &#39;Auxilin&#39;, color=cg, fontsize=25, fontweight=&#39;bold&#39;)
        if plot_z:
            plt.text(len(row[&#34;Z&#34;]), row[&#34;Z&#34;][-1], &#39;Dynamin&#39;, color=&#39;gray&#39;, fontsize=25, fontweight=&#39;bold&#39;)
    plt.tight_layout()
    return dft


def viz_errs_2d(df, idxs_test, preds, Y_test, key1=&#39;x_pos&#39;, key2=&#39;y_pos&#39;, X=None, plot_correct=True):
    &#39;&#39;&#39;visualize distribution of errs wrt to 2 dimensions
    &#39;&#39;&#39;
    x_pos = df[key1].iloc[idxs_test]
    y_pos = df[key2].iloc[idxs_test]

    plt.figure(dpi=200)
    ms = 4
    me = 1
    if plot_correct:
        plt.plot(x_pos[(preds == Y_test) &amp; (preds == 1)], y_pos[(preds == Y_test) &amp; (preds == 1)], &#39;o&#39;,
                 color=cb, alpha=0.4, label=&#39;true pos&#39;, ms=ms, markeredgewidth=0)
        plt.plot(x_pos[(preds == Y_test) &amp; (preds == 0)], y_pos[(preds == Y_test) &amp; (preds == 0)], &#39;o&#39;,
                 color=cr, alpha=0.4, label=&#39;true neg&#39;, ms=ms, markeredgewidth=0)
    plt.plot(x_pos[preds &gt; Y_test], y_pos[preds &gt; Y_test], &#39;x&#39;, color=cb,
             alpha=0.4, label=&#39;false pos&#39;, ms=ms, markeredgewidth=1)
    plt.plot(x_pos[preds &lt; Y_test], y_pos[preds &lt; Y_test], &#39;x&#39;, color=cr,
             alpha=0.4, label=&#39;false neg&#39;, ms=ms, markeredgewidth=1)
    plt.legend()
    #     plt.scatter(x_pos, y_pos, c=preds==Y_test, alpha=0.5)
    plt.xlabel(key1)
    plt.ylabel(key2)
    plt.tight_layout()


def viz_errs_1d(X_test, preds, preds_proba, Y_test, norms, key=&#39;lifetime&#39;):
    &#39;&#39;&#39;visualize errs based on lifetime
    &#39;&#39;&#39;
    plt.figure(dpi=200)
    correct_idxs = preds == Y_test
    lifetime = X_test[key] * norms[key][&#39;std&#39;] + norms[key][&#39;mu&#39;]

    plt.plot(lifetime[(preds == Y_test) &amp; (preds == 1)], preds_proba[(preds == Y_test) &amp; (preds == 1)], &#39;o&#39;,
             color=cb, alpha=0.5, label=&#39;true pos&#39;)
    plt.plot(lifetime[(preds == Y_test) &amp; (preds == 0)], preds_proba[(preds == Y_test) &amp; (preds == 0)], &#39;x&#39;,
             color=cb, alpha=0.5, label=&#39;true neg&#39;)
    plt.plot(lifetime[preds &gt; Y_test], preds_proba[preds &gt; Y_test], &#39;o&#39;, color=cr, alpha=0.5, label=&#39;false pos&#39;)
    plt.plot(lifetime[preds &lt; Y_test], preds_proba[preds &lt; Y_test], &#39;x&#39;, color=cr, alpha=0.5, label=&#39;false neg&#39;)
    plt.xlabel(key)
    plt.ylabel(&#39;predicted probability&#39;)
    plt.legend()
    plt.show()


def plot_curves(df, extra_key=None, extra_key_label=None,
                hline=True, R=5, C=8,
                fig=None, ylim_constant=False, xlim_constant=True, legend=True, plot_x=True):
    &#39;&#39;&#39;Plot time-series curves from df
    &#39;&#39;&#39;
    if fig is None:
        plt.figure(figsize=(16, 10), dpi=200, facecolor=&#39;white&#39;)
    lifetime_max = np.max(df.lifetime.values[:R * C])
    df = df.iloc[range(R * C)]
    for i in range(R * C):
        if i &lt; df.shape[0]:
            plt.subplot(R, C, i + 1)
            row = df.iloc[i]
            if plot_x:
                plt.plot(row.X, color=cr, label=&#39;Clathrin&#39;)
                plt.plot(row.Y, color=cg, label=&#39;Auxilin&#39;)
                if hline:
                    plt.axhline(642.3754691658837, color=&#39;gray&#39;, alpha=0.5)
            if extra_key is not None:
                if extra_key_label is None:
                    if extra_key == &#39;Z&#39;:
                        extra_key_label = &#39;Dynamin&#39;
                    else:
                        extra_key_label = extra_key
                plt.plot(row[extra_key], color=&#39;gray&#39;, label=extra_key_label)
            if xlim_constant:
                plt.xlim([-1, lifetime_max + 1])
            if ylim_constant:
                plt.ylim([-10, max(max(df.X_max), max(df.Y_max)) + 1])
    #     plt.axi(&#39;off&#39;)
    if legend:
        plt.legend()
    plt.tight_layout()
    if fig is None:
        plt.show()


def viz_errs_outliers_venn(X_test, preds, Y_test, num_feats_reduced=5):
    &#39;&#39;&#39;Compare outliers to errors in venn-diagram
    &#39;&#39;&#39;
    feat_names = data.get_feature_names(X_test)
    X_feat = X_test[feat_names]

    if num_feats_reduced is not None:
        pca = decomposition.PCA(n_components=num_feats_reduced)
        X_reduced = pca.fit_transform(X_feat)
    else:
        X_reduced = X_feat

    R, C = 2, 2
    titles = [&#39;isolation forest&#39;, &#39;local outlier factor&#39;, &#39;elliptic envelop&#39;, &#39;one-class svm&#39;]
    plt.figure(figsize=(6, 5), dpi=200)
    for i in range(4):
        plt.subplot(R, C, i + 1)
        plt.title(titles[i])
        if i == 0:
            clf = IsolationForest(n_estimators=10, warm_start=True)
        elif i == 1:
            clf = LocalOutlierFactor(novelty=True)
        elif i == 2:
            clf = EllipticEnvelope()
        elif i == 3:
            clf = OneClassSVM()
        clf.fit(X_reduced)  # fit 10 trees  
        is_outlier = clf.predict(X_reduced) == -1
        is_err = preds != Y_test
        idxs = np.arange(is_outlier.size)
        venn2([set(idxs[is_outlier]), set(idxs[is_err])], set_labels=[&#39;outliers&#39;, &#39;errors&#39;])


def plot_pcs(pca, X):
    &#39;&#39;&#39;Pretty plot of pcs with explained var bars
    Params
    ------
    pca: sklearn PCA class after being fitted
    &#39;&#39;&#39;
    plt.figure(figsize=(6, 9), dpi=200)

    # extract out relevant pars
    comps = pca.components_.transpose()
    var_norm = pca.explained_variance_ / np.sum(pca.explained_variance_) * 100

    # create a 2 X 2 grid 
    gs = grd.GridSpec(2, 2, height_ratios=[2, 10],
                      width_ratios=[12, 1], wspace=0.1, hspace=0)

    # plot explained variance
    ax2 = plt.subplot(gs[0])
    ax2.bar(np.arange(0, comps.shape[1]), var_norm,
            color=&#39;gray&#39;, width=0.8)
    plt.title(&#39;Explained variance (%)&#39;)
    ax2.spines[&#39;right&#39;].set_visible(False)
    ax2.spines[&#39;top&#39;].set_visible(False)
    ax2.yaxis.set_ticks_position(&#39;left&#39;)
    ax2.set_yticks([0, max(var_norm)])
    plt.xlim((-0.5, comps.shape[1] - 0.5))

    # plot pcs
    ax = plt.subplot(gs[2])
    vmaxabs = np.max(np.abs(comps))
    p = ax.imshow(comps, interpolation=&#39;None&#39;, aspect=&#39;auto&#39;,
                  cmap=sns.diverging_palette(10, 240, as_cmap=True, center=&#39;light&#39;),
                  vmin=-vmaxabs, vmax=vmaxabs)  # center at 0
    plt.xlabel(&#39;PCA component number&#39;)
    ax.set_yticklabels(list(X))
    ax.set_yticks(range(len(list(X))))

    # make colorbar
    colorAx = plt.subplot(gs[3])
    cb = plt.colorbar(p, cax=colorAx)
    plt.show()


def print_metadata(acc=None, metadata_file=oj(config.DIR_PROCESSED, &#39;metadata_clath_aux+gak_a7d2.pkl&#39;)):
    m = pkl.load(open(metadata_file, &#39;rb&#39;))

    print(
        f&#39;valid:\t\t{m[&#34;num_aux_pos_valid&#34;]:&gt;4.0f} aux+ / {m[&#34;num_tracks_valid&#34;]:&gt;4.0f} ({m[&#34;num_aux_pos_valid&#34;] / m[&#34;num_tracks_valid&#34;]:.3f})&#39;)
    print(&#39;----------------------------------------&#39;)
    print(f&#39;hotspots:\t{m[&#34;num_hotspots_valid&#34;]:&gt;4.0f} aux+ / {m[&#34;num_hotspots_valid&#34;]:&gt;4.0f}&#39;)
    print(
        f&#39;short:\t\t{m[&#34;num_short&#34;] - m[&#34;num_short&#34;] * m[&#34;acc_short&#34;]:&gt;4.0f} aux+ / {m[&#34;num_short&#34;]:&gt;4.0f} ({m[&#34;acc_short&#34;]:.3f})&#39;)
    print(f&#39;long:\t\t{m[&#34;num_long&#34;] * m[&#34;acc_long&#34;]:&gt;4.0f} aux+ / {m[&#34;num_long&#34;]:&gt;4.0f} ({m[&#34;acc_long&#34;]:.3f})&#39;)
    print(
        f&#39;hard:\t\t{m[&#34;num_aux_pos_hard&#34;]:&gt;4.0f} aux+ / {m[&#34;num_tracks_hard&#34;]:&gt;4.0f} ({m[&#34;num_aux_pos_hard&#34;] / m[&#34;num_tracks_hard&#34;]:.3f})&#39;)

    if acc is not None:
        print(&#39;----------------------------------------&#39;)
        print(f&#39;hard acc:\t\t\t  {acc:.3f}&#39;)
        num_eval = m[&#34;num_tracks_valid&#34;] - m[&#34;num_hotspots_valid&#34;]
    #         print(
    #             f&#39;total acc (no hotspots):\t  {(m[&#34;num_short&#34;] * m[&#34;acc_short&#34;] + m[&#34;num_long&#34;] * m[&#34;acc_long&#34;] + acc * m[&#34;num_tracks_hard&#34;]) / num_eval:.3f}&#39;)
    print(&#39;\nlifetime threshes&#39;, m[&#39;thresh_short&#39;], m[&#39;thresh_long&#39;])


def jointplot_grouped(col_x: str, col_y: str, col_k: str, df,
                      k_is_color=False, scatter_alpha=.5, add_global_hists: bool = False, ms=None):
    &#39;&#39;&#39;Jointplot of hists + densities
    Params
    ------
    col_x
        name of X var
    col_y
        name of Y var
    col_k
        name of variable to group/color by
    add_global_hists
        whether to plot the global hist as well
    &#39;&#39;&#39;

    def colored_scatter(x, y, c=None):
        def scatter(*args, **kwargs):
            args = (x, y)
            if c is not None:
                kwargs[&#39;c&#39;] = c
            kwargs[&#39;marker&#39;] = &#39;.&#39;
            kwargs[&#39;alpha&#39;] = scatter_alpha
            plt.scatter(*args, **kwargs)

        return scatter

    g = sns.JointGrid(
        x=col_x,
        y=col_y,
        data=df
    )
    color = None
    legends = []
    for name, df_group in df.groupby(col_k):
        legends.append(name)
        if k_is_color:
            color = name
        g.plot_joint(
            colored_scatter(df_group[col_x], df_group[col_y], color),
        )
        sns.distplot(
            df_group[col_x].values,
            ax=g.ax_marg_x,
            color=color,
        )
        sns.distplot(
            df_group[col_y].values,
            ax=g.ax_marg_y,
            color=color,
            vertical=True
        )
    if add_global_hists:
        sns.distplot(
            df[col_x].values,
            ax=g.ax_marg_x,
            color=&#39;grey&#39;
        )
        sns.distplot(
            df[col_y].values.ravel(),
            ax=g.ax_marg_y,
            color=&#39;grey&#39;,
            vertical=True
        )
    plt.legend(legends)


# 2d decision boundary
def plot_decision_boundary(X_col, Y_col, m, df, norms, num_pts=100):
    &#39;&#39;&#39;still not finished...
    &#39;&#39;&#39;
    x = df[X_col]
    y = df[Y_col]
    x = np.linspace(x.min(), x.max(), num_pts)
    y = np.linspace(y.min(), y.max(), num_pts)

    # normalize
    xv, yv = np.meshgrid(x, y, indexing=&#39;ij&#39;)
    x = xv.flatten()
    y = yv.flatten()
    x = (x - norms[X_col][&#39;mu&#39;]) / (norms[X_col][&#39;std&#39;])
    y = (y - norms[Y_col][&#39;mu&#39;]) / (norms[Y_col][&#39;std&#39;])

    X = np.hstack((x, y)).reshape(-1, 2)
    print(X.shape)

    X = df[results_individual[&#39;feat_names_selected&#39;]]

    preds = m.predict(X)


def cumulative_acc_plot_hard(preds_proba, preds, y_full_cv):
    args = np.argsort(np.abs(preds_proba - 0.5))[::-1]
    accs = (preds == y_full_cv)[args]
    n = accs.size
    accs = np.cumsum(accs) / np.arange(1, n + 1)

    plt.figure(dpi=500)
    plt.plot(preds_proba[args], &#39;.&#39;, ms=0.5, label=&#39;predicted prob&#39;, color=cb)
    plt.plot(accs, label=&#39;cumulative acc&#39;, color=cr)
    plt.yticks(np.arange(-0.05, 1.05, 0.1))
    plt.xlabel(&#39;num pts included&#39;)
    plt.grid(alpha=0.2)
    plt.legend()
    plt.show()


def cumulative_acc_plot_all(df, pred_proba_key=&#39;preds_proba&#39;, pred_key=&#39;preds&#39;,
                            outcome_def=&#39;y_consec_thresh&#39;,
                            plot_vert_line_for_high_lifetimes=False, show=True):
    plt.figure(dpi=500)
    ax = plt.subplot(111)
    
    # full (no model)
    argsf = np.argsort(df.lifetime.values)
    accsf = (1 - df[outcome_def]).values[argsf]
    n = df.shape[0]
    plt.plot(np.cumsum(accsf) / np.arange(1, accsf.size + 1), label=&#39;No model&#39;, color=&#39;gray&#39;)
    print(&#39;accsf&#39;, np.sum(accsf))
    
    # short
    ds = df[df.short]
    argss = np.argsort(ds.lifetime.values)
    accss = (1 - ds[outcome_def]).values[argss]
    ns = ds.shape[0]
    # hard
    dh = df[~df.short]
    argsh = np.argsort(np.abs(dh[pred_key])) #[::-1]
    accsh = ((dh[pred_key].values &gt; 0) == dh[outcome_def].values)[argsh]
    # put things together
    accs = np.hstack((accss, accsh))
    print(accsf.shape, accss.shape, accsh.shape, accs.shape)
    plt.plot(np.cumsum(accs) / np.arange(1, accs.size + 1), label=&#39;With model&#39;, color=cb)
    print(accs)
    plt.axvline(ns, lw=2.5, color=&#39;black&#39;)
    
    
    plt.xlabel(&#39;Percentage of tracks included (sorted by uncertainty)&#39;)
    plt.ylabel(&#39;Accuracy&#39;)
    ax.xaxis.set_ticks([int(x) for x in np.arange(0, n + 1, n//5)])
    ax.xaxis.set_ticklabels([str(int(x)) + &#39;%&#39; for x in np.arange(0, 101, 100/5)])
    plt.legend(fontsize=&#39;x-large&#39;, frameon=False)
    plt.grid(alpha=0.2)
    plt.tight_layout()

def plot_example(ex):
    &#39;&#39;&#39;ex - row of the dataframe
    &#39;&#39;&#39;
    plt.figure(dpi=200)
    plt.plot(ex[&#39;X&#39;], color=&#39;red&#39;, label=&#39;clathrin&#39;)
    plt.plot(ex[&#39;Y&#39;], color=&#39;green&#39;, label=&#39;auxilin&#39;)
    plt.xlabel(&#39;Time&#39;)
    plt.ylabel(&#39;Amplitude&#39;)
    plt.legend()
    
def get_images(cell_dir: str):
    &#39;&#39;&#39;Loads in X and Y for one cell
    
    Params
    ------
    cell_dir
        Path to directory for one cell
    
    Returns
    -------
    X : np.ndarray
        has shape (W, H, num_images)
    Y : np.ndarray
        has shape (W, H, num_images)
    &#39;&#39;&#39;
    for name in os.listdir(oj(cell_dir, &#39;TagRFP&#39;)):
        #print(f&#34;filename: {name}&#34;)
        if &#39;tif&#39; in name:
            fname1 = name
    for name in os.listdir(oj(cell_dir, &#39;EGFP&#39;)):
        if &#39;tif&#39; in name:
            fname2 = name
    #print(cell_dir)
    X = imread(oj(cell_dir, &#39;TagRFP&#39;, fname1))  # .astype(np.float32) # X = RFP(clathrin) (num_images x H x W)
    Y = imread(oj(cell_dir, &#39;EGFP&#39;, fname2))  # .astype(np.float32) # Y = EGFP (auxilin) (num_image x H x W)
    return X, Y
    
def get_dynamin_images(cells):
    
    cla, aux = {}, {}
    upper_dir = oj(&#39;/scratch/users/vision/data/abc_data/dynamin_data_with_ims/&#39;,
               &#39;CLTA-TagRFP EGFP-Aux1-GAK-F6 Dyn2-Halo-E1-JF646&#39;)
    for cell_num in cells:
        cell_dir = cell_num[:-6] + &#39;Cell1_1.5s&#39;
        full_dir = oj(upper_dir, cell_dir)
        cla[cell_num], aux[cell_num] = get_images(full_dir)
    return cla, aux

def get_dynamin_data_video(df, pids, add_px=2):
    
    &#34;&#34;&#34;
    extract videos of dynamin traces 
    
    Params:
    ------
    df: pd.DataFrame
        dataframe
    
    pids: list
        list of pids to plot
        
    add_px: int
        number of additional pixels in each direction
        add_px=1 means 3*3 pixels around the center, add_px=2 means 5*5, etc.
        
    Returns:
    ------
    cla_videos, aux_videos: dictionary
        Indexed by pid
        For each pid, the value is an np.2darray
        Each element in the list is one frame of (2 * add_px + 1) * (2 * add_px + 1) image around the center
        Range is [0, 1]
    
    &#34;&#34;&#34;
    
    indices = np.array([np.where(df.pid.values == pid)[0][0] for pid in pids])
    df = df.iloc[indices]
    cells = set(df.cell_num.values)
    X, Y = get_dynamin_images(cells)
    
    cla_videos, aux_videos = {}, {}
    
    for i in range(len(df)):
        cla, aux = [], []
        cell_num = df.cell_num.iloc[i]
        pid = df.pid.iloc[i]
        x_pos, y_pos = df.x_pos_seq.iloc[i], df.y_pos_seq.iloc[i]
        t, lt = df.t.iloc[i], min(len(x_pos), len(y_pos))                

        for j in range(lt):
            aux.append(Y[cell_num][int((t+j)/1.5),:,:] \
                                  [range(int(y_pos[j]) - add_px, int(y_pos[j]) + add_px + 1), :] \
                                  [:, range(int(x_pos[j]) - add_px, int(x_pos[j]) + add_px + 1)])
            
            # normalize by the min/max intensities
            vmin, vmax = Y[cell_num][int((t+j)/1.5),:,:].min(), Y[cell_num][int((t+j)/1.5),:,:].max()
            aux[j] = (aux[j] - vmin)/(vmax - vmin)
            
            cla.append(X[cell_num][int((t+j)/1.5),:,:] \
                                  [range(int(y_pos[j]) - add_px, int(y_pos[j]) + add_px + 1), :] \
                                  [:, range(int(x_pos[j]) - add_px, int(x_pos[j]) + add_px + 1)]) 
            vmin, vmax = X[cell_num][int((t+j)/1.5),:,:].min(), X[cell_num][int((t+j)/1.5),:,:].max()
            cla[j] = (cla[j] - vmin)/(vmax - vmin)
            
        cla_videos[pid], aux_videos[pid] = cla, aux
    
    return cla_videos, aux_videos
    

def plot_kymographs(df, pids, add_px=2):
    
    &#34;&#34;&#34;
    plot kymographs of dynamin traces 
    
    Params:
    ------
    df: pd.DataFrame
        dataframe
    
    pids: list
        list of pids to plot
        
    add_px: int
        number of additional pixels in each direction
        add_px=1 means 3*3 pixels around the center, add_px=2 means 5*5, etc.
        
    Returns:
    ------
    cla_traces: np.array
        clathrin traces from raw images
    aux_traces: np.array
        auxilin traces from raw images
    rgb_image: 3d np.array
        3d array (RGB values) of kymographs
    &#34;&#34;&#34;
    
    indices = np.array([np.where(df.pid.values == pid)[0][0] for pid in pids])
    df = df.iloc[indices]
    cells = set(df.cell_num.values)
    X, Y = get_dynamin_images(cells)
    viridis = cm.get_cmap(&#39;viridis&#39;, 12)
    reds = cm.get_cmap(&#39;Reds&#39;, 12) # red palette for clathrin
    greens = cm.get_cmap(&#39;Greens&#39;, 12) # green palette for auxilin
    
    lmax = max([len(df.x_pos_seq.iloc[i]) for i in range(len(df))]) + 2
    width = 2 * add_px + 1
    cla_traces, aux_traces = {}, {}
    
    for i in range(len(df)):
        cla_traces[i], aux_traces[i] = np.zeros((lmax, width)), np.zeros((lmax, width))
        #xmean = X[df.cell_num.iloc[i]].mean()
        cell_num = df.cell_num.iloc[i]
        x_pos, y_pos = df.x_pos_seq.iloc[i], df.y_pos_seq.iloc[i]
        t, lt = df.t.iloc[i], min(len(x_pos), len(y_pos))        
        
        for k in range(-add_px, add_px + 1):
            for j in range(lt):
                cla_traces[i][j, k] = max(X[cell_num][int((t+j)/1.5), \
                                                      range(int(y_pos[j]) - add_px, int(y_pos[j]) + add_px + 1), \
                                                      int(x_pos[j] + k)])
                vmin, vmax = X[cell_num][int((t+j)/1.5),:,:].min(), X[cell_num][int((t+j)/1.5),:,:].max()
                cla_traces[i][j, k] = (cla_traces[i][j, k] - vmin)/(vmax - vmin)
                
                aux_traces[i][j, k] = max(Y[cell_num][int((t+j)/1.5), \
                                                      range(int(y_pos[j]) - add_px, int(y_pos[j]) + add_px + 1), \
                                                      int(x_pos[j] + k)])
                vmin, vmax = Y[cell_num][int((t+j)/1.5),:,:].min(), Y[cell_num][int((t+j)/1.5),:,:].max()
                aux_traces[i][j, k] = (aux_traces[i][j, k] - vmin)/(vmax - vmin)                
    
    ncol = 3 * width * len(df)
    cla_sparse = np.zeros((lmax, ncol))
    aux_sparse = np.zeros((lmax, ncol))
    for i in range(len(df)):
        start_index = 3 * width * i
        cla_sparse[:, (start_index):(start_index + width)] = cla_traces[i]
        aux_sparse[:, (start_index + width):(start_index + 2 * width)] = aux_traces[i]
    
    rgb_image = np.array([[list(reds(cla_sparse[i][j])[:3])
                      #[1, 1 - cla_sparse[i][j], 1 - cla_sparse[i][j]] \
                      if 0 &lt; cla_sparse[i][j] &lt; 1 \
                      else \
                      list(greens(aux_sparse[i][j])[:3]) \
                      #[1 - aux_sparse[i][j], 1, 1 - aux_sparse[i][j]] \
                      if 0 &lt; aux_sparse[i][j] &lt; 1 \
                      #else list(viridis(np.random.choice(background, 1)[0])[:3])\
                      else (1, 1, 1)
                      for i in range(lmax)] \
                      for j in range(ncol)])
    #cla_sparse = np.transpose(cla_sparse)
    #aux_sparse = np.transpose(aux_sparse)
    return cla_traces, aux_traces, rgb_image</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="src.viz.cumulative_acc_plot_all"><code class="name flex">
<span>def <span class="ident">cumulative_acc_plot_all</span></span>(<span>df, pred_proba_key='preds_proba', pred_key='preds', outcome_def='y_consec_thresh', plot_vert_line_for_high_lifetimes=False, show=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cumulative_acc_plot_all(df, pred_proba_key=&#39;preds_proba&#39;, pred_key=&#39;preds&#39;,
                            outcome_def=&#39;y_consec_thresh&#39;,
                            plot_vert_line_for_high_lifetimes=False, show=True):
    plt.figure(dpi=500)
    ax = plt.subplot(111)
    
    # full (no model)
    argsf = np.argsort(df.lifetime.values)
    accsf = (1 - df[outcome_def]).values[argsf]
    n = df.shape[0]
    plt.plot(np.cumsum(accsf) / np.arange(1, accsf.size + 1), label=&#39;No model&#39;, color=&#39;gray&#39;)
    print(&#39;accsf&#39;, np.sum(accsf))
    
    # short
    ds = df[df.short]
    argss = np.argsort(ds.lifetime.values)
    accss = (1 - ds[outcome_def]).values[argss]
    ns = ds.shape[0]
    # hard
    dh = df[~df.short]
    argsh = np.argsort(np.abs(dh[pred_key])) #[::-1]
    accsh = ((dh[pred_key].values &gt; 0) == dh[outcome_def].values)[argsh]
    # put things together
    accs = np.hstack((accss, accsh))
    print(accsf.shape, accss.shape, accsh.shape, accs.shape)
    plt.plot(np.cumsum(accs) / np.arange(1, accs.size + 1), label=&#39;With model&#39;, color=cb)
    print(accs)
    plt.axvline(ns, lw=2.5, color=&#39;black&#39;)
    
    
    plt.xlabel(&#39;Percentage of tracks included (sorted by uncertainty)&#39;)
    plt.ylabel(&#39;Accuracy&#39;)
    ax.xaxis.set_ticks([int(x) for x in np.arange(0, n + 1, n//5)])
    ax.xaxis.set_ticklabels([str(int(x)) + &#39;%&#39; for x in np.arange(0, 101, 100/5)])
    plt.legend(fontsize=&#39;x-large&#39;, frameon=False)
    plt.grid(alpha=0.2)
    plt.tight_layout()</code></pre>
</details>
</dd>
<dt id="src.viz.cumulative_acc_plot_hard"><code class="name flex">
<span>def <span class="ident">cumulative_acc_plot_hard</span></span>(<span>preds_proba, preds, y_full_cv)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cumulative_acc_plot_hard(preds_proba, preds, y_full_cv):
    args = np.argsort(np.abs(preds_proba - 0.5))[::-1]
    accs = (preds == y_full_cv)[args]
    n = accs.size
    accs = np.cumsum(accs) / np.arange(1, n + 1)

    plt.figure(dpi=500)
    plt.plot(preds_proba[args], &#39;.&#39;, ms=0.5, label=&#39;predicted prob&#39;, color=cb)
    plt.plot(accs, label=&#39;cumulative acc&#39;, color=cr)
    plt.yticks(np.arange(-0.05, 1.05, 0.1))
    plt.xlabel(&#39;num pts included&#39;)
    plt.grid(alpha=0.2)
    plt.legend()
    plt.show()</code></pre>
</details>
</dd>
<dt id="src.viz.fix_feat_name"><code class="name flex">
<span>def <span class="ident">fix_feat_name</span></span>(<span>s)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fix_feat_name(s):
    return s.replace(&#39;_&#39;, &#39; &#39;).replace(&#39;X&#39;, &#39;Clath&#39;).capitalize()</code></pre>
</details>
</dd>
<dt id="src.viz.get_dynamin_data_video"><code class="name flex">
<span>def <span class="ident">get_dynamin_data_video</span></span>(<span>df, pids, add_px=2)</span>
</code></dt>
<dd>
<section class="desc"><p>extract videos of dynamin traces </p>
<h2 id="params">Params:</h2>
<p>df: pd.DataFrame
dataframe</p>
<p>pids: list
list of pids to plot</p>
<p>add_px: int
number of additional pixels in each direction
add_px=1 means 3<em>3 pixels around the center, add_px=2 means 5</em>5, etc.</p>
<h2 id="returns">Returns:</h2>
<p>cla_videos, aux_videos: dictionary
Indexed by pid
For each pid, the value is an np.2darray
Each element in the list is one frame of (2 * add_px + 1) * (2 * add_px + 1) image around the center
Range is [0, 1]</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dynamin_data_video(df, pids, add_px=2):
    
    &#34;&#34;&#34;
    extract videos of dynamin traces 
    
    Params:
    ------
    df: pd.DataFrame
        dataframe
    
    pids: list
        list of pids to plot
        
    add_px: int
        number of additional pixels in each direction
        add_px=1 means 3*3 pixels around the center, add_px=2 means 5*5, etc.
        
    Returns:
    ------
    cla_videos, aux_videos: dictionary
        Indexed by pid
        For each pid, the value is an np.2darray
        Each element in the list is one frame of (2 * add_px + 1) * (2 * add_px + 1) image around the center
        Range is [0, 1]
    
    &#34;&#34;&#34;
    
    indices = np.array([np.where(df.pid.values == pid)[0][0] for pid in pids])
    df = df.iloc[indices]
    cells = set(df.cell_num.values)
    X, Y = get_dynamin_images(cells)
    
    cla_videos, aux_videos = {}, {}
    
    for i in range(len(df)):
        cla, aux = [], []
        cell_num = df.cell_num.iloc[i]
        pid = df.pid.iloc[i]
        x_pos, y_pos = df.x_pos_seq.iloc[i], df.y_pos_seq.iloc[i]
        t, lt = df.t.iloc[i], min(len(x_pos), len(y_pos))                

        for j in range(lt):
            aux.append(Y[cell_num][int((t+j)/1.5),:,:] \
                                  [range(int(y_pos[j]) - add_px, int(y_pos[j]) + add_px + 1), :] \
                                  [:, range(int(x_pos[j]) - add_px, int(x_pos[j]) + add_px + 1)])
            
            # normalize by the min/max intensities
            vmin, vmax = Y[cell_num][int((t+j)/1.5),:,:].min(), Y[cell_num][int((t+j)/1.5),:,:].max()
            aux[j] = (aux[j] - vmin)/(vmax - vmin)
            
            cla.append(X[cell_num][int((t+j)/1.5),:,:] \
                                  [range(int(y_pos[j]) - add_px, int(y_pos[j]) + add_px + 1), :] \
                                  [:, range(int(x_pos[j]) - add_px, int(x_pos[j]) + add_px + 1)]) 
            vmin, vmax = X[cell_num][int((t+j)/1.5),:,:].min(), X[cell_num][int((t+j)/1.5),:,:].max()
            cla[j] = (cla[j] - vmin)/(vmax - vmin)
            
        cla_videos[pid], aux_videos[pid] = cla, aux
    
    return cla_videos, aux_videos</code></pre>
</details>
</dd>
<dt id="src.viz.get_dynamin_images"><code class="name flex">
<span>def <span class="ident">get_dynamin_images</span></span>(<span>cells)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dynamin_images(cells):
    
    cla, aux = {}, {}
    upper_dir = oj(&#39;/scratch/users/vision/data/abc_data/dynamin_data_with_ims/&#39;,
               &#39;CLTA-TagRFP EGFP-Aux1-GAK-F6 Dyn2-Halo-E1-JF646&#39;)
    for cell_num in cells:
        cell_dir = cell_num[:-6] + &#39;Cell1_1.5s&#39;
        full_dir = oj(upper_dir, cell_dir)
        cla[cell_num], aux[cell_num] = get_images(full_dir)
    return cla, aux</code></pre>
</details>
</dd>
<dt id="src.viz.get_images"><code class="name flex">
<span>def <span class="ident">get_images</span></span>(<span>cell_dir)</span>
</code></dt>
<dd>
<section class="desc"><p>Loads in X and Y for one cell</p>
<h2 id="params">Params</h2>
<dl>
<dt><strong><code>cell_dir</code></strong></dt>
<dd>Path to directory for one cell</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>has shape (W, H, num_images)</dd>
<dt><strong><code>Y</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>has shape (W, H, num_images)</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_images(cell_dir: str):
    &#39;&#39;&#39;Loads in X and Y for one cell
    
    Params
    ------
    cell_dir
        Path to directory for one cell
    
    Returns
    -------
    X : np.ndarray
        has shape (W, H, num_images)
    Y : np.ndarray
        has shape (W, H, num_images)
    &#39;&#39;&#39;
    for name in os.listdir(oj(cell_dir, &#39;TagRFP&#39;)):
        #print(f&#34;filename: {name}&#34;)
        if &#39;tif&#39; in name:
            fname1 = name
    for name in os.listdir(oj(cell_dir, &#39;EGFP&#39;)):
        if &#39;tif&#39; in name:
            fname2 = name
    #print(cell_dir)
    X = imread(oj(cell_dir, &#39;TagRFP&#39;, fname1))  # .astype(np.float32) # X = RFP(clathrin) (num_images x H x W)
    Y = imread(oj(cell_dir, &#39;EGFP&#39;, fname2))  # .astype(np.float32) # Y = EGFP (auxilin) (num_image x H x W)
    return X, Y</code></pre>
</details>
</dd>
<dt id="src.viz.highlight_max"><code class="name flex">
<span>def <span class="ident">highlight_max</span></span>(<span>data, color='#0e5c99')</span>
</code></dt>
<dd>
<section class="desc"><p>highlight the maximum in a Series or DataFrame</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def highlight_max(data, color=&#39;#0e5c99&#39;):
    &#39;&#39;&#39;
    highlight the maximum in a Series or DataFrame
    &#39;&#39;&#39;
    attr = &#39;background-color: {}&#39;.format(color)
    if data.ndim == 1:  # Series from .apply(axis=0) or axis=1
        is_max = data == data.max()
        return [attr if v else &#39;&#39; for v in is_max]
    else:  # from .apply(axis=None)
        is_max = data == data.max().max()
        return pd.DataFrame(np.where(is_max, attr, &#39;&#39;),
                            index=data.index, columns=data.columns)</code></pre>
</details>
</dd>
<dt id="src.viz.jointplot_grouped"><code class="name flex">
<span>def <span class="ident">jointplot_grouped</span></span>(<span>col_x, col_y, col_k, df, k_is_color=False, scatter_alpha=0.5, add_global_hists=False, ms=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Jointplot of hists + densities
Params</p>
<hr>
<dl>
<dt><strong><code>col_x</code></strong></dt>
<dd>name of X var</dd>
<dt><strong><code>col_y</code></strong></dt>
<dd>name of Y var</dd>
<dt><strong><code>col_k</code></strong></dt>
<dd>name of variable to group/color by</dd>
<dt><strong><code>add_global_hists</code></strong></dt>
<dd>whether to plot the global hist as well</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jointplot_grouped(col_x: str, col_y: str, col_k: str, df,
                      k_is_color=False, scatter_alpha=.5, add_global_hists: bool = False, ms=None):
    &#39;&#39;&#39;Jointplot of hists + densities
    Params
    ------
    col_x
        name of X var
    col_y
        name of Y var
    col_k
        name of variable to group/color by
    add_global_hists
        whether to plot the global hist as well
    &#39;&#39;&#39;

    def colored_scatter(x, y, c=None):
        def scatter(*args, **kwargs):
            args = (x, y)
            if c is not None:
                kwargs[&#39;c&#39;] = c
            kwargs[&#39;marker&#39;] = &#39;.&#39;
            kwargs[&#39;alpha&#39;] = scatter_alpha
            plt.scatter(*args, **kwargs)

        return scatter

    g = sns.JointGrid(
        x=col_x,
        y=col_y,
        data=df
    )
    color = None
    legends = []
    for name, df_group in df.groupby(col_k):
        legends.append(name)
        if k_is_color:
            color = name
        g.plot_joint(
            colored_scatter(df_group[col_x], df_group[col_y], color),
        )
        sns.distplot(
            df_group[col_x].values,
            ax=g.ax_marg_x,
            color=color,
        )
        sns.distplot(
            df_group[col_y].values,
            ax=g.ax_marg_y,
            color=color,
            vertical=True
        )
    if add_global_hists:
        sns.distplot(
            df[col_x].values,
            ax=g.ax_marg_x,
            color=&#39;grey&#39;
        )
        sns.distplot(
            df[col_y].values.ravel(),
            ax=g.ax_marg_y,
            color=&#39;grey&#39;,
            vertical=True
        )
    plt.legend(legends)</code></pre>
</details>
</dd>
<dt id="src.viz.plot_confusion_matrix"><code class="name flex">
<span>def <span class="ident">plot_confusion_matrix</span></span>(<span>y_true, y_pred, classes, normalize=False, title=None, cmap=&lt;matplotlib.colors.LinearSegmentedColormap object&gt;)</span>
</code></dt>
<dd>
<section class="desc"><p>This function prints and plots the confusion matrix.
Normalization can be applied by setting <code>normalize=True</code>.
Params</p>
<hr>
<dl>
<dt><strong><code>classes</code></strong> :&ensp;<code>np.ndarray</code>(<code>Str</code>)</dt>
<dd>classes=np.array(['aux-', 'aux+'])</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_confusion_matrix(y_true, y_pred, classes,
                          normalize=False,
                          title=None,
                          cmap=plt.cm.Blues):
    &#34;&#34;&#34;
    This function prints and plots the confusion matrix.
    Normalization can be applied by setting `normalize=True`.
    Params
    ------
    classes: np.ndarray(Str)
        classes=np.array([&#39;aux-&#39;, &#39;aux+&#39;])
    &#34;&#34;&#34;
    plt.figure(dpi=300)
    if not title:
        if normalize:
            title = &#39;Normalized confusion matrix&#39;
        else:
            title = &#39;Confusion matrix, without normalization&#39;

    # Compute confusion matrix
    cm = metrics.confusion_matrix(y_true, y_pred)
    # Only use the labels that appear in the data
    classes = classes[unique_labels(y_true.astype(np.int), y_pred.astype(np.int))]
    if normalize:
        cm = cm.astype(&#39;float&#39;) / cm.sum(axis=1)[:, np.newaxis]

    #     fig, ax = plt.subplots()
    im = plt.imshow(cm, interpolation=&#39;nearest&#39;, cmap=cmap)
    ax = plt.gca()
    #     ax.figure.colorbar(im, ax=ax)
    # We want to show all ticks...
    ax.set(xticks=np.arange(cm.shape[1]),
           yticks=np.arange(cm.shape[0]),
           # ... and label them with the respective list entries
           xticklabels=classes, yticklabels=classes,
           #            title=title,
           ylabel=&#39;True label&#39;,
           xlabel=&#39;Predicted label&#39;)

    # Rotate the tick labels and set their alignment.
    plt.setp(ax.get_xticklabels(), rotation=45, ha=&#34;right&#34;,
             rotation_mode=&#34;anchor&#34;)

    # Loop over data dimensions and create text annotations.
    fmt = &#39;.2f&#39; if normalize else &#39;d&#39;
    thresh = cm.max() / 2.
    for i in range(cm.shape[0]):
        for j in range(cm.shape[1]):
            ax.text(j, i, format(cm[i, j], fmt),
                    ha=&#34;center&#34;, va=&#34;center&#34;,
                    color=&#34;white&#34; if cm[i, j] &gt; thresh else &#34;black&#34;)
    return ax</code></pre>
</details>
</dd>
<dt id="src.viz.plot_curves"><code class="name flex">
<span>def <span class="ident">plot_curves</span></span>(<span>df, extra_key=None, extra_key_label=None, hline=True, R=5, C=8, fig=None, ylim_constant=False, xlim_constant=True, legend=True, plot_x=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Plot time-series curves from df</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_curves(df, extra_key=None, extra_key_label=None,
                hline=True, R=5, C=8,
                fig=None, ylim_constant=False, xlim_constant=True, legend=True, plot_x=True):
    &#39;&#39;&#39;Plot time-series curves from df
    &#39;&#39;&#39;
    if fig is None:
        plt.figure(figsize=(16, 10), dpi=200, facecolor=&#39;white&#39;)
    lifetime_max = np.max(df.lifetime.values[:R * C])
    df = df.iloc[range(R * C)]
    for i in range(R * C):
        if i &lt; df.shape[0]:
            plt.subplot(R, C, i + 1)
            row = df.iloc[i]
            if plot_x:
                plt.plot(row.X, color=cr, label=&#39;Clathrin&#39;)
                plt.plot(row.Y, color=cg, label=&#39;Auxilin&#39;)
                if hline:
                    plt.axhline(642.3754691658837, color=&#39;gray&#39;, alpha=0.5)
            if extra_key is not None:
                if extra_key_label is None:
                    if extra_key == &#39;Z&#39;:
                        extra_key_label = &#39;Dynamin&#39;
                    else:
                        extra_key_label = extra_key
                plt.plot(row[extra_key], color=&#39;gray&#39;, label=extra_key_label)
            if xlim_constant:
                plt.xlim([-1, lifetime_max + 1])
            if ylim_constant:
                plt.ylim([-10, max(max(df.X_max), max(df.Y_max)) + 1])
    #     plt.axi(&#39;off&#39;)
    if legend:
        plt.legend()
    plt.tight_layout()
    if fig is None:
        plt.show()</code></pre>
</details>
</dd>
<dt id="src.viz.plot_decision_boundary"><code class="name flex">
<span>def <span class="ident">plot_decision_boundary</span></span>(<span>X_col, Y_col, m, df, norms, num_pts=100)</span>
</code></dt>
<dd>
<section class="desc"><p>still not finished&hellip;</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_decision_boundary(X_col, Y_col, m, df, norms, num_pts=100):
    &#39;&#39;&#39;still not finished...
    &#39;&#39;&#39;
    x = df[X_col]
    y = df[Y_col]
    x = np.linspace(x.min(), x.max(), num_pts)
    y = np.linspace(y.min(), y.max(), num_pts)

    # normalize
    xv, yv = np.meshgrid(x, y, indexing=&#39;ij&#39;)
    x = xv.flatten()
    y = yv.flatten()
    x = (x - norms[X_col][&#39;mu&#39;]) / (norms[X_col][&#39;std&#39;])
    y = (y - norms[Y_col][&#39;mu&#39;]) / (norms[Y_col][&#39;std&#39;])

    X = np.hstack((x, y)).reshape(-1, 2)
    print(X.shape)

    X = df[results_individual[&#39;feat_names_selected&#39;]]

    preds = m.predict(X)</code></pre>
</details>
</dd>
<dt id="src.viz.plot_example"><code class="name flex">
<span>def <span class="ident">plot_example</span></span>(<span>ex)</span>
</code></dt>
<dd>
<section class="desc"><p>ex - row of the dataframe</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_example(ex):
    &#39;&#39;&#39;ex - row of the dataframe
    &#39;&#39;&#39;
    plt.figure(dpi=200)
    plt.plot(ex[&#39;X&#39;], color=&#39;red&#39;, label=&#39;clathrin&#39;)
    plt.plot(ex[&#39;Y&#39;], color=&#39;green&#39;, label=&#39;auxilin&#39;)
    plt.xlabel(&#39;Time&#39;)
    plt.ylabel(&#39;Amplitude&#39;)
    plt.legend()</code></pre>
</details>
</dd>
<dt id="src.viz.plot_kymographs"><code class="name flex">
<span>def <span class="ident">plot_kymographs</span></span>(<span>df, pids, add_px=2)</span>
</code></dt>
<dd>
<section class="desc"><p>plot kymographs of dynamin traces </p>
<h2 id="params">Params:</h2>
<p>df: pd.DataFrame
dataframe</p>
<p>pids: list
list of pids to plot</p>
<p>add_px: int
number of additional pixels in each direction
add_px=1 means 3<em>3 pixels around the center, add_px=2 means 5</em>5, etc.</p>
<h2 id="returns">Returns:</h2>
<p>cla_traces: np.array
clathrin traces from raw images
aux_traces: np.array
auxilin traces from raw images
rgb_image: 3d np.array
3d array (RGB values) of kymographs</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_kymographs(df, pids, add_px=2):
    
    &#34;&#34;&#34;
    plot kymographs of dynamin traces 
    
    Params:
    ------
    df: pd.DataFrame
        dataframe
    
    pids: list
        list of pids to plot
        
    add_px: int
        number of additional pixels in each direction
        add_px=1 means 3*3 pixels around the center, add_px=2 means 5*5, etc.
        
    Returns:
    ------
    cla_traces: np.array
        clathrin traces from raw images
    aux_traces: np.array
        auxilin traces from raw images
    rgb_image: 3d np.array
        3d array (RGB values) of kymographs
    &#34;&#34;&#34;
    
    indices = np.array([np.where(df.pid.values == pid)[0][0] for pid in pids])
    df = df.iloc[indices]
    cells = set(df.cell_num.values)
    X, Y = get_dynamin_images(cells)
    viridis = cm.get_cmap(&#39;viridis&#39;, 12)
    reds = cm.get_cmap(&#39;Reds&#39;, 12) # red palette for clathrin
    greens = cm.get_cmap(&#39;Greens&#39;, 12) # green palette for auxilin
    
    lmax = max([len(df.x_pos_seq.iloc[i]) for i in range(len(df))]) + 2
    width = 2 * add_px + 1
    cla_traces, aux_traces = {}, {}
    
    for i in range(len(df)):
        cla_traces[i], aux_traces[i] = np.zeros((lmax, width)), np.zeros((lmax, width))
        #xmean = X[df.cell_num.iloc[i]].mean()
        cell_num = df.cell_num.iloc[i]
        x_pos, y_pos = df.x_pos_seq.iloc[i], df.y_pos_seq.iloc[i]
        t, lt = df.t.iloc[i], min(len(x_pos), len(y_pos))        
        
        for k in range(-add_px, add_px + 1):
            for j in range(lt):
                cla_traces[i][j, k] = max(X[cell_num][int((t+j)/1.5), \
                                                      range(int(y_pos[j]) - add_px, int(y_pos[j]) + add_px + 1), \
                                                      int(x_pos[j] + k)])
                vmin, vmax = X[cell_num][int((t+j)/1.5),:,:].min(), X[cell_num][int((t+j)/1.5),:,:].max()
                cla_traces[i][j, k] = (cla_traces[i][j, k] - vmin)/(vmax - vmin)
                
                aux_traces[i][j, k] = max(Y[cell_num][int((t+j)/1.5), \
                                                      range(int(y_pos[j]) - add_px, int(y_pos[j]) + add_px + 1), \
                                                      int(x_pos[j] + k)])
                vmin, vmax = Y[cell_num][int((t+j)/1.5),:,:].min(), Y[cell_num][int((t+j)/1.5),:,:].max()
                aux_traces[i][j, k] = (aux_traces[i][j, k] - vmin)/(vmax - vmin)                
    
    ncol = 3 * width * len(df)
    cla_sparse = np.zeros((lmax, ncol))
    aux_sparse = np.zeros((lmax, ncol))
    for i in range(len(df)):
        start_index = 3 * width * i
        cla_sparse[:, (start_index):(start_index + width)] = cla_traces[i]
        aux_sparse[:, (start_index + width):(start_index + 2 * width)] = aux_traces[i]
    
    rgb_image = np.array([[list(reds(cla_sparse[i][j])[:3])
                      #[1, 1 - cla_sparse[i][j], 1 - cla_sparse[i][j]] \
                      if 0 &lt; cla_sparse[i][j] &lt; 1 \
                      else \
                      list(greens(aux_sparse[i][j])[:3]) \
                      #[1 - aux_sparse[i][j], 1, 1 - aux_sparse[i][j]] \
                      if 0 &lt; aux_sparse[i][j] &lt; 1 \
                      #else list(viridis(np.random.choice(background, 1)[0])[:3])\
                      else (1, 1, 1)
                      for i in range(lmax)] \
                      for j in range(ncol)])
    #cla_sparse = np.transpose(cla_sparse)
    #aux_sparse = np.transpose(aux_sparse)
    return cla_traces, aux_traces, rgb_image</code></pre>
</details>
</dd>
<dt id="src.viz.plot_pcs"><code class="name flex">
<span>def <span class="ident">plot_pcs</span></span>(<span>pca, X)</span>
</code></dt>
<dd>
<section class="desc"><p>Pretty plot of pcs with explained var bars
Params</p>
<hr>
<dl>
<dt><strong><code>pca</code></strong> :&ensp;<code>sklearn</code> <code>PCA</code> <code>class</code> <code>after</code> <code>being</code> <code>fitted</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_pcs(pca, X):
    &#39;&#39;&#39;Pretty plot of pcs with explained var bars
    Params
    ------
    pca: sklearn PCA class after being fitted
    &#39;&#39;&#39;
    plt.figure(figsize=(6, 9), dpi=200)

    # extract out relevant pars
    comps = pca.components_.transpose()
    var_norm = pca.explained_variance_ / np.sum(pca.explained_variance_) * 100

    # create a 2 X 2 grid 
    gs = grd.GridSpec(2, 2, height_ratios=[2, 10],
                      width_ratios=[12, 1], wspace=0.1, hspace=0)

    # plot explained variance
    ax2 = plt.subplot(gs[0])
    ax2.bar(np.arange(0, comps.shape[1]), var_norm,
            color=&#39;gray&#39;, width=0.8)
    plt.title(&#39;Explained variance (%)&#39;)
    ax2.spines[&#39;right&#39;].set_visible(False)
    ax2.spines[&#39;top&#39;].set_visible(False)
    ax2.yaxis.set_ticks_position(&#39;left&#39;)
    ax2.set_yticks([0, max(var_norm)])
    plt.xlim((-0.5, comps.shape[1] - 0.5))

    # plot pcs
    ax = plt.subplot(gs[2])
    vmaxabs = np.max(np.abs(comps))
    p = ax.imshow(comps, interpolation=&#39;None&#39;, aspect=&#39;auto&#39;,
                  cmap=sns.diverging_palette(10, 240, as_cmap=True, center=&#39;light&#39;),
                  vmin=-vmaxabs, vmax=vmaxabs)  # center at 0
    plt.xlabel(&#39;PCA component number&#39;)
    ax.set_yticklabels(list(X))
    ax.set_yticks(range(len(list(X))))

    # make colorbar
    colorAx = plt.subplot(gs[3])
    cb = plt.colorbar(p, cax=colorAx)
    plt.show()</code></pre>
</details>
</dd>
<dt id="src.viz.print_metadata"><code class="name flex">
<span>def <span class="ident">print_metadata</span></span>(<span>acc=None, metadata_file='/accounts/projects/vision/chandan/auxilin-prediction/src/../data/processed/metadata_clath_aux+gak_a7d2.pkl')</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_metadata(acc=None, metadata_file=oj(config.DIR_PROCESSED, &#39;metadata_clath_aux+gak_a7d2.pkl&#39;)):
    m = pkl.load(open(metadata_file, &#39;rb&#39;))

    print(
        f&#39;valid:\t\t{m[&#34;num_aux_pos_valid&#34;]:&gt;4.0f} aux+ / {m[&#34;num_tracks_valid&#34;]:&gt;4.0f} ({m[&#34;num_aux_pos_valid&#34;] / m[&#34;num_tracks_valid&#34;]:.3f})&#39;)
    print(&#39;----------------------------------------&#39;)
    print(f&#39;hotspots:\t{m[&#34;num_hotspots_valid&#34;]:&gt;4.0f} aux+ / {m[&#34;num_hotspots_valid&#34;]:&gt;4.0f}&#39;)
    print(
        f&#39;short:\t\t{m[&#34;num_short&#34;] - m[&#34;num_short&#34;] * m[&#34;acc_short&#34;]:&gt;4.0f} aux+ / {m[&#34;num_short&#34;]:&gt;4.0f} ({m[&#34;acc_short&#34;]:.3f})&#39;)
    print(f&#39;long:\t\t{m[&#34;num_long&#34;] * m[&#34;acc_long&#34;]:&gt;4.0f} aux+ / {m[&#34;num_long&#34;]:&gt;4.0f} ({m[&#34;acc_long&#34;]:.3f})&#39;)
    print(
        f&#39;hard:\t\t{m[&#34;num_aux_pos_hard&#34;]:&gt;4.0f} aux+ / {m[&#34;num_tracks_hard&#34;]:&gt;4.0f} ({m[&#34;num_aux_pos_hard&#34;] / m[&#34;num_tracks_hard&#34;]:.3f})&#39;)

    if acc is not None:
        print(&#39;----------------------------------------&#39;)
        print(f&#39;hard acc:\t\t\t  {acc:.3f}&#39;)
        num_eval = m[&#34;num_tracks_valid&#34;] - m[&#34;num_hotspots_valid&#34;]
    #         print(
    #             f&#39;total acc (no hotspots):\t  {(m[&#34;num_short&#34;] * m[&#34;acc_short&#34;] + m[&#34;num_long&#34;] * m[&#34;acc_long&#34;] + acc * m[&#34;num_tracks_hard&#34;]) / num_eval:.3f}&#39;)
    print(&#39;\nlifetime threshes&#39;, m[&#39;thresh_short&#39;], m[&#39;thresh_long&#39;])</code></pre>
</details>
</dd>
<dt id="src.viz.savefig"><code class="name flex">
<span>def <span class="ident">savefig</span></span>(<span>s, png=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def savefig(s: str, png=False):
#     plt.tight_layout()
    plt.savefig(oj(DIR_FIGS, &#39;fig_&#39; + s + &#39;.pdf&#39;), bbox_inches=&#39;tight&#39;)
    if png:
        plt.savefig(oj(DIR_FIGS, &#39;fig_&#39; + s + &#39;.png&#39;), dpi=300, bbox_inches=&#39;tight&#39;)</code></pre>
</details>
</dd>
<dt id="src.viz.viz_biggest_errs"><code class="name flex">
<span>def <span class="ident">viz_biggest_errs</span></span>(<span>df, idxs_cv, idxs, Y_test, preds, preds_proba, num_to_plot=20, aux_thresh=642, show_track_num=True, show_track_pid=False, sort_by_residuals=True, plot_x=True, plot_y=True, plot_z=False, xlim_constant=True, lifetime_max=None, text_labels=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Visualize X and Y where the top examples are the most wrong / least confident
Params</p>
<hr>
<dl>
<dt><strong><code>idxs_cv</code></strong> :&ensp;<code>integer</code> <code>ndarray</code></dt>
<dd>which idxs are not part of the test set (usually just 0, 1, 2, &hellip;)</dd>
<dt><strong><code>idxs</code></strong> :&ensp;<code>boolean</code> <code>ndarray</code></dt>
<dd>subset of points to plot</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def viz_biggest_errs(df, idxs_cv, idxs, Y_test, preds, preds_proba,
                     num_to_plot=20,
                     aux_thresh=642,
                     show_track_num=True,
                     show_track_pid=False,
                     sort_by_residuals=True,
                     plot_x=True,
                     plot_y=True,
                     plot_z=False,
                     xlim_constant=True,
                     lifetime_max=None,
                     text_labels=False):
    &#39;&#39;&#39;Visualize X and Y where the top examples are the most wrong / least confident
    Params
    ------
    idxs_cv: integer ndarray
        which idxs are not part of the test set (usually just 0, 1, 2, ...)
    idxs: boolean ndarray
        subset of points to plot
    
    &#39;&#39;&#39;

    
    # deal with idxs
    if idxs is not None:
        Y_test = Y_test[idxs]
        preds = preds[idxs]
        preds_proba = preds_proba[idxs]
        if idxs_cv is None:
            idxs_cv = np.arange(df.shape[0])
        df = df.iloc[idxs_cv][idxs]
    
    # get args to sort by
    if sort_by_residuals:
        residuals = np.abs(Y_test - preds_proba)
        args = np.argsort(residuals)[::-1]
        dft = df.iloc[args]
    else:
        dft = df
    if lifetime_max is None:
        lifetime_max = np.max(dft.lifetime.values)
    if num_to_plot is None:
        num_to_plot = dft.shape[0]
    R = int(np.sqrt(num_to_plot))
    C = num_to_plot // R  # + 1
    plt.figure(figsize=(C * 3, R * 2.5), dpi=200)

    i = 0
    for r in range(R):
        for c in range(C):
            if i &lt; dft.shape[0]:
                row = dft.iloc[i]
                ax = plt.subplot(R, C, i + 1)
                # show nums on tracks
                if show_track_num:
                    ax.text(.5, .9, f&#39;{i}&#39;, # row.pid
                            horizontalalignment=&#39;right&#39;,
                            transform=ax.transAxes)
                elif show_track_pid:
                    ax.text(.5, .9, f&#39;{row.pid}&#39;, # row.pid
                            horizontalalignment=&#39;right&#39;,
                            transform=ax.transAxes)
                plt.axis(&#39;off&#39;)
                
                if plot_x:
                    plt.plot(row[&#34;X&#34;], color=cr, label=&#39;clath&#39;, lw=2) # could do X_extended
                if plot_y:
                    plt.plot(row[&#34;Y&#34;], color=cg, label=&#39;aux&#39;, lw=2)
                if plot_z:
                    plt.plot(row[&#34;Z&#34;], color=&#39;gray&#39;, label=&#39;dyn&#39;)

                if xlim_constant:
                    plt.xlim([-1, lifetime_max])
                plt.axhline(aux_thresh, color=&#39;gray&#39;, alpha=0.5, lw=2)
                i += 1
                
    if text_labels:
        plt.text(len(row[&#34;X&#34;]), row[&#34;X&#34;][-1], &#39;Clathrin&#39;, color=cr, fontsize=25, fontweight=&#39;bold&#39;)
        plt.text(len(row[&#34;Y&#34;]), row[&#34;Y&#34;][-1], &#39;Auxilin&#39;, color=cg, fontsize=25, fontweight=&#39;bold&#39;)
        if plot_z:
            plt.text(len(row[&#34;Z&#34;]), row[&#34;Z&#34;][-1], &#39;Dynamin&#39;, color=&#39;gray&#39;, fontsize=25, fontweight=&#39;bold&#39;)
    plt.tight_layout()
    return dft</code></pre>
</details>
</dd>
<dt id="src.viz.viz_errs_1d"><code class="name flex">
<span>def <span class="ident">viz_errs_1d</span></span>(<span>X_test, preds, preds_proba, Y_test, norms, key='lifetime')</span>
</code></dt>
<dd>
<section class="desc"><p>visualize errs based on lifetime</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def viz_errs_1d(X_test, preds, preds_proba, Y_test, norms, key=&#39;lifetime&#39;):
    &#39;&#39;&#39;visualize errs based on lifetime
    &#39;&#39;&#39;
    plt.figure(dpi=200)
    correct_idxs = preds == Y_test
    lifetime = X_test[key] * norms[key][&#39;std&#39;] + norms[key][&#39;mu&#39;]

    plt.plot(lifetime[(preds == Y_test) &amp; (preds == 1)], preds_proba[(preds == Y_test) &amp; (preds == 1)], &#39;o&#39;,
             color=cb, alpha=0.5, label=&#39;true pos&#39;)
    plt.plot(lifetime[(preds == Y_test) &amp; (preds == 0)], preds_proba[(preds == Y_test) &amp; (preds == 0)], &#39;x&#39;,
             color=cb, alpha=0.5, label=&#39;true neg&#39;)
    plt.plot(lifetime[preds &gt; Y_test], preds_proba[preds &gt; Y_test], &#39;o&#39;, color=cr, alpha=0.5, label=&#39;false pos&#39;)
    plt.plot(lifetime[preds &lt; Y_test], preds_proba[preds &lt; Y_test], &#39;x&#39;, color=cr, alpha=0.5, label=&#39;false neg&#39;)
    plt.xlabel(key)
    plt.ylabel(&#39;predicted probability&#39;)
    plt.legend()
    plt.show()</code></pre>
</details>
</dd>
<dt id="src.viz.viz_errs_2d"><code class="name flex">
<span>def <span class="ident">viz_errs_2d</span></span>(<span>df, idxs_test, preds, Y_test, key1='x_pos', key2='y_pos', X=None, plot_correct=True)</span>
</code></dt>
<dd>
<section class="desc"><p>visualize distribution of errs wrt to 2 dimensions</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def viz_errs_2d(df, idxs_test, preds, Y_test, key1=&#39;x_pos&#39;, key2=&#39;y_pos&#39;, X=None, plot_correct=True):
    &#39;&#39;&#39;visualize distribution of errs wrt to 2 dimensions
    &#39;&#39;&#39;
    x_pos = df[key1].iloc[idxs_test]
    y_pos = df[key2].iloc[idxs_test]

    plt.figure(dpi=200)
    ms = 4
    me = 1
    if plot_correct:
        plt.plot(x_pos[(preds == Y_test) &amp; (preds == 1)], y_pos[(preds == Y_test) &amp; (preds == 1)], &#39;o&#39;,
                 color=cb, alpha=0.4, label=&#39;true pos&#39;, ms=ms, markeredgewidth=0)
        plt.plot(x_pos[(preds == Y_test) &amp; (preds == 0)], y_pos[(preds == Y_test) &amp; (preds == 0)], &#39;o&#39;,
                 color=cr, alpha=0.4, label=&#39;true neg&#39;, ms=ms, markeredgewidth=0)
    plt.plot(x_pos[preds &gt; Y_test], y_pos[preds &gt; Y_test], &#39;x&#39;, color=cb,
             alpha=0.4, label=&#39;false pos&#39;, ms=ms, markeredgewidth=1)
    plt.plot(x_pos[preds &lt; Y_test], y_pos[preds &lt; Y_test], &#39;x&#39;, color=cr,
             alpha=0.4, label=&#39;false neg&#39;, ms=ms, markeredgewidth=1)
    plt.legend()
    #     plt.scatter(x_pos, y_pos, c=preds==Y_test, alpha=0.5)
    plt.xlabel(key1)
    plt.ylabel(key2)
    plt.tight_layout()</code></pre>
</details>
</dd>
<dt id="src.viz.viz_errs_outliers_venn"><code class="name flex">
<span>def <span class="ident">viz_errs_outliers_venn</span></span>(<span>X_test, preds, Y_test, num_feats_reduced=5)</span>
</code></dt>
<dd>
<section class="desc"><p>Compare outliers to errors in venn-diagram</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def viz_errs_outliers_venn(X_test, preds, Y_test, num_feats_reduced=5):
    &#39;&#39;&#39;Compare outliers to errors in venn-diagram
    &#39;&#39;&#39;
    feat_names = data.get_feature_names(X_test)
    X_feat = X_test[feat_names]

    if num_feats_reduced is not None:
        pca = decomposition.PCA(n_components=num_feats_reduced)
        X_reduced = pca.fit_transform(X_feat)
    else:
        X_reduced = X_feat

    R, C = 2, 2
    titles = [&#39;isolation forest&#39;, &#39;local outlier factor&#39;, &#39;elliptic envelop&#39;, &#39;one-class svm&#39;]
    plt.figure(figsize=(6, 5), dpi=200)
    for i in range(4):
        plt.subplot(R, C, i + 1)
        plt.title(titles[i])
        if i == 0:
            clf = IsolationForest(n_estimators=10, warm_start=True)
        elif i == 1:
            clf = LocalOutlierFactor(novelty=True)
        elif i == 2:
            clf = EllipticEnvelope()
        elif i == 3:
            clf = OneClassSVM()
        clf.fit(X_reduced)  # fit 10 trees  
        is_outlier = clf.predict(X_reduced) == -1
        is_err = preds != Y_test
        idxs = np.arange(is_outlier.size)
        venn2([set(idxs[is_outlier]), set(idxs[is_err])], set_labels=[&#39;outliers&#39;, &#39;errors&#39;])</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src" href="index.html">src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="src.viz.cumulative_acc_plot_all" href="#src.viz.cumulative_acc_plot_all">cumulative_acc_plot_all</a></code></li>
<li><code><a title="src.viz.cumulative_acc_plot_hard" href="#src.viz.cumulative_acc_plot_hard">cumulative_acc_plot_hard</a></code></li>
<li><code><a title="src.viz.fix_feat_name" href="#src.viz.fix_feat_name">fix_feat_name</a></code></li>
<li><code><a title="src.viz.get_dynamin_data_video" href="#src.viz.get_dynamin_data_video">get_dynamin_data_video</a></code></li>
<li><code><a title="src.viz.get_dynamin_images" href="#src.viz.get_dynamin_images">get_dynamin_images</a></code></li>
<li><code><a title="src.viz.get_images" href="#src.viz.get_images">get_images</a></code></li>
<li><code><a title="src.viz.highlight_max" href="#src.viz.highlight_max">highlight_max</a></code></li>
<li><code><a title="src.viz.jointplot_grouped" href="#src.viz.jointplot_grouped">jointplot_grouped</a></code></li>
<li><code><a title="src.viz.plot_confusion_matrix" href="#src.viz.plot_confusion_matrix">plot_confusion_matrix</a></code></li>
<li><code><a title="src.viz.plot_curves" href="#src.viz.plot_curves">plot_curves</a></code></li>
<li><code><a title="src.viz.plot_decision_boundary" href="#src.viz.plot_decision_boundary">plot_decision_boundary</a></code></li>
<li><code><a title="src.viz.plot_example" href="#src.viz.plot_example">plot_example</a></code></li>
<li><code><a title="src.viz.plot_kymographs" href="#src.viz.plot_kymographs">plot_kymographs</a></code></li>
<li><code><a title="src.viz.plot_pcs" href="#src.viz.plot_pcs">plot_pcs</a></code></li>
<li><code><a title="src.viz.print_metadata" href="#src.viz.print_metadata">print_metadata</a></code></li>
<li><code><a title="src.viz.savefig" href="#src.viz.savefig">savefig</a></code></li>
<li><code><a title="src.viz.viz_biggest_errs" href="#src.viz.viz_biggest_errs">viz_biggest_errs</a></code></li>
<li><code><a title="src.viz.viz_errs_1d" href="#src.viz.viz_errs_1d">viz_errs_1d</a></code></li>
<li><code><a title="src.viz.viz_errs_2d" href="#src.viz.viz_errs_2d">viz_errs_2d</a></code></li>
<li><code><a title="src.viz.viz_errs_outliers_venn" href="#src.viz.viz_errs_outliers_venn">viz_errs_outliers_venn</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>