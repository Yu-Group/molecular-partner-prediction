<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>src.viz API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.viz</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import pickle as pkl
import sys
sys.path.append(&#39;..&#39;)
import config
import data
from os.path import join as oj
import matplotlib.gridspec as grd
import numpy as np
import pandas as pd
import seaborn as sns
from matplotlib import pyplot as plt
from matplotlib_venn import venn2
from sklearn import decomposition
from sklearn import metrics
from sklearn.covariance import EllipticEnvelope
from sklearn.ensemble import IsolationForest
from sklearn.neighbors import LocalOutlierFactor
from sklearn.svm import OneClassSVM
from sklearn.utils.multiclass import unique_labels
import os
import matplotlib.ticker as mtick
from config import DIR_FIGS
from matplotlib.colors import LinearSegmentedColormap
from matplotlib import cm
from matplotlib.colors import ListedColormap
import dvu
# DIR_FILE = os.path.dirname(os.path.realpath(__file__)) # directory of this file
# DIR_FIGS = oj(DIR_FILE, &#39;../reports/figs&#39;)
try:
    from skimage.external.tifffile import imread
except:
    from skimage.io import imread


cb2 = &#39;#66ccff&#39;
cb = &#39;#1f77b4&#39;
co = &#39;#ff7f0e&#39;
cr = &#39;#cc0000&#39;
cp = &#39;#cc3399&#39;
cy = &#39;#d8b365&#39;
cg = &#39;#5ab4ac&#39;
cmap = LinearSegmentedColormap.from_list(
    name=&#39;orange-blue&#39;, 
    colors=[(205/255, 85/255, 51/255),
            &#39;lightgray&#39;,
            (50/255, 129/255, 168/255)]
)

def savefig(s: str, png=False):
#     plt.tight_layout()
    plt.savefig(oj(DIR_FIGS, &#39;fig_&#39; + s + &#39;.pdf&#39;), bbox_inches=&#39;tight&#39;)
    if png:
        plt.savefig(oj(DIR_FIGS, &#39;fig_&#39; + s + &#39;.png&#39;), dpi=300, bbox_inches=&#39;tight&#39;)
    

def fix_feat_name(s):
    return s.replace(&#39;_&#39;, &#39; &#39;).replace(&#39;X&#39;, &#39;Clath&#39;).capitalize()

def plot_confusion_matrix(y_true, y_pred, classes,
                          normalize=False,
                          title=None,
                          cmap=plt.cm.Blues):
    &#34;&#34;&#34;
    This function prints and plots the confusion matrix.
    Normalization can be applied by setting `normalize=True`.
    Params
    ------
    classes: np.ndarray(Str)
        classes=np.array([&#39;aux-&#39;, &#39;aux+&#39;])
    &#34;&#34;&#34;
    plt.figure(dpi=300)
    if not title:
        if normalize:
            title = &#39;Normalized confusion matrix&#39;
        else:
            title = &#39;Confusion matrix, without normalization&#39;

    # Compute confusion matrix
    cm = metrics.confusion_matrix(y_true, y_pred)
    # Only use the labels that appear in the data
    classes = classes[unique_labels(y_true.astype(np.int), y_pred.astype(np.int))]
    if normalize:
        cm = cm.astype(&#39;float&#39;) / cm.sum(axis=1)[:, np.newaxis]

    #     fig, ax = plt.subplots()
    im = plt.imshow(cm, interpolation=&#39;nearest&#39;, cmap=cmap)
    ax = plt.gca()
    #     ax.figure.colorbar(im, ax=ax)
    # We want to show all ticks...
    ax.set(xticks=np.arange(cm.shape[1]),
           yticks=np.arange(cm.shape[0]),
           # ... and label them with the respective list entries
           xticklabels=classes, yticklabels=classes,
           #            title=title,
           ylabel=&#39;True label&#39;,
           xlabel=&#39;Predicted label&#39;)

    # Rotate the tick labels and set their alignment.
    plt.setp(ax.get_xticklabels(), rotation=45, ha=&#34;right&#34;,
             rotation_mode=&#34;anchor&#34;)

    # Loop over data dimensions and create text annotations.
    fmt = &#39;.2f&#39; if normalize else &#39;d&#39;
    thresh = cm.max() / 2.
    for i in range(cm.shape[0]):
        for j in range(cm.shape[1]):
            ax.text(j, i, format(cm[i, j], fmt),
                    ha=&#34;center&#34;, va=&#34;center&#34;,
                    color=&#34;white&#34; if cm[i, j] &gt; thresh else &#34;black&#34;)
    return ax


def highlight_max(data, color=&#39;#0e5c99&#39;):
    &#39;&#39;&#39;
    highlight the maximum in a Series or DataFrame
    &#39;&#39;&#39;
    attr = &#39;background-color: {}&#39;.format(color)
    if data.ndim == 1:  # Series from .apply(axis=0) or axis=1
        is_max = data == data.max()
        return [attr if v else &#39;&#39; for v in is_max]
    else:  # from .apply(axis=None)
        is_max = data == data.max().max()
        return pd.DataFrame(np.where(is_max, attr, &#39;&#39;),
                            index=data.index, columns=data.columns)


# visualize biggest errs
def viz_biggest_errs(df, idxs_cv, idxs, Y_test, preds, preds_proba,
                     num_to_plot=20,
                     aux_thresh=642,
                     show_track_num=True,
                     show_track_pid=False,
                     sort_by_residuals=True,
                     width_mult=3,
                     plot_x=True,
                     plot_y=True,
                     plot_z=False,
                     plot_axhline=True,
                     xlim_constant=True,
                     ylim: tuple=None,
                     yticks=None,
                     yticklabels=None,
                     lifetime_max=None,
                     text_labels=False,
                     text_label_size=25):
    &#39;&#39;&#39;Visualize X and Y where the top examples are the most wrong / least confident
    Params
    ------
    idxs_cv: integer ndarray
        which idxs are not part of the test set (usually just 0, 1, 2, ...)
    idxs: boolean ndarray
        subset of points to plot
    
    &#39;&#39;&#39;
    DIFF = 0 # use this to ensure values are all positive
    
    # deal with idxs
    if idxs is not None:
        Y_test = Y_test[idxs]
        preds = preds[idxs]
        preds_proba = preds_proba[idxs]
        if idxs_cv is None:
            idxs_cv = np.arange(df.shape[0])
        df = df.iloc[idxs_cv][idxs]
    
    # get args to sort by
    if sort_by_residuals:
        residuals = np.abs(Y_test - preds_proba)
        args = np.argsort(residuals)[::-1]
        dft = df.iloc[args]
    else:
        dft = df
    if lifetime_max is None:
        lifetime_max = np.max(dft.lifetime.values)
    if num_to_plot is None:
        num_to_plot = dft.shape[0]
    R = int(np.sqrt(num_to_plot))
    C = num_to_plot // R  # + 1
    plt.figure(figsize=(C * width_mult, R * 2.5), dpi=200)

    i = 0
    for r in range(R):
        for c in range(C):
            if i &lt; dft.shape[0]:
                row = dft.iloc[i]
                ax = plt.subplot(R, C, i + 1)
                # show nums on tracks
                if show_track_num:
                    ax.text(.5, .9, f&#39;{i}&#39;, # row.pid
                            horizontalalignment=&#39;right&#39;,
                            transform=ax.transAxes)
                elif show_track_pid:
                    ax.text(.5, .9, f&#39;{row.pid}&#39;, # row.pid
                            horizontalalignment=&#39;right&#39;,
                            transform=ax.transAxes)

#                 plt.axis(&#39;off&#39;)
                if &#39;1.5s&#39; in row[&#39;cell_num&#39;]:
                    interval = 1.5
                else:
                    interval = 1
                if plot_x:
                    plt.plot(interval * np.arange(len(row[&#34;X&#34;])), np.array(row[&#34;X&#34;]) + DIFF, color=cr, label=&#39;clath&#39;, lw=2) # could do X_extended
                if plot_y:
                    plt.plot(interval * np.arange(len(row[&#34;Y&#34;])), np.array(row[&#34;Y&#34;]) + DIFF, color=cg, label=&#39;aux&#39;, lw=2)
                if plot_z:
                    plt.plot(interval * np.arange(len(row[&#34;Z&#34;])), np.array(row[&#34;Z&#34;]) + DIFF, color=&#39;gray&#39;, label=&#39;dyn&#39;)               
                    
                if xlim_constant:
                    plt.xlim([-1, lifetime_max])
                
                if plot_axhline:
                    plt.axhline(aux_thresh, color=&#39;gray&#39;, alpha=0.5, lw=2)
                
                #plt.yscale(&#39;log&#39;)
                if ylim is not None:
                    plt.ylim((ylim[0] + DIFF, ylim[1] + DIFF))
                    
                if not r == R - 1:
                    plt.xticks([])
                if not c == 0:
                    plt.yticks([])     
                elif yticks is not None:
                    plt.yticks(yticks, labels=yticklabels)

                i += 1
                
    if text_labels:
        plt.text(len(row[&#34;X&#34;]), row[&#34;X&#34;][-1] + DIFF, &#39;Clathrin&#39;, color=cr, 
                 fontsize=text_label_size, fontweight=&#39;bold&#39;)
        plt.text(len(row[&#34;Y&#34;]), row[&#34;Y&#34;][-1] + DIFF, &#39;Auxilin&#39;, color=cg, 
                 fontsize=text_label_size, fontweight=&#39;bold&#39;)
        if plot_z:
            plt.text(len(row[&#34;Z&#34;]), row[&#34;Z&#34;][-1] + DIFF, &#39;Dynamin&#39;, 
                     fontsize=text_label_size, color=&#39;gray&#39;, fontweight=&#39;bold&#39;)
    plt.tight_layout()
    return dft


def viz_errs_2d(df, idxs_test, preds, Y_test, key1=&#39;x_pos&#39;, key2=&#39;y_pos&#39;, X=None, plot_correct=True):
    &#39;&#39;&#39;visualize distribution of errs wrt to 2 dimensions
    &#39;&#39;&#39;
    x_pos = df[key1].iloc[idxs_test]
    y_pos = df[key2].iloc[idxs_test]

    plt.figure(dpi=200)
    ms = 4
    me = 1
    if plot_correct:
        plt.plot(x_pos[(preds == Y_test) &amp; (preds == 1)], y_pos[(preds == Y_test) &amp; (preds == 1)], &#39;o&#39;,
                 color=cb, alpha=0.4, label=&#39;true pos&#39;, ms=ms, markeredgewidth=0)
        plt.plot(x_pos[(preds == Y_test) &amp; (preds == 0)], y_pos[(preds == Y_test) &amp; (preds == 0)], &#39;o&#39;,
                 color=cr, alpha=0.4, label=&#39;true neg&#39;, ms=ms, markeredgewidth=0)
    plt.plot(x_pos[preds &gt; Y_test], y_pos[preds &gt; Y_test], &#39;x&#39;, color=cb,
             alpha=0.4, label=&#39;false pos&#39;, ms=ms, markeredgewidth=1)
    plt.plot(x_pos[preds &lt; Y_test], y_pos[preds &lt; Y_test], &#39;x&#39;, color=cr,
             alpha=0.4, label=&#39;false neg&#39;, ms=ms, markeredgewidth=1)
    plt.legend()
    #     plt.scatter(x_pos, y_pos, c=preds==Y_test, alpha=0.5)
    plt.xlabel(key1)
    plt.ylabel(key2)
    plt.tight_layout()


def viz_errs_1d(X_test, preds, preds_proba, Y_test, norms, key=&#39;lifetime&#39;):
    &#39;&#39;&#39;visualize errs based on lifetime
    &#39;&#39;&#39;
    plt.figure(dpi=200)
    correct_idxs = preds == Y_test
    lifetime = X_test[key] * norms[key][&#39;std&#39;] + norms[key][&#39;mu&#39;]

    plt.plot(lifetime[(preds == Y_test) &amp; (preds == 1)], preds_proba[(preds == Y_test) &amp; (preds == 1)], &#39;o&#39;,
             color=cb, alpha=0.5, label=&#39;true pos&#39;)
    plt.plot(lifetime[(preds == Y_test) &amp; (preds == 0)], preds_proba[(preds == Y_test) &amp; (preds == 0)], &#39;x&#39;,
             color=cb, alpha=0.5, label=&#39;true neg&#39;)
    plt.plot(lifetime[preds &gt; Y_test], preds_proba[preds &gt; Y_test], &#39;o&#39;, color=cr, alpha=0.5, label=&#39;false pos&#39;)
    plt.plot(lifetime[preds &lt; Y_test], preds_proba[preds &lt; Y_test], &#39;x&#39;, color=cr, alpha=0.5, label=&#39;false neg&#39;)
    plt.xlabel(key)
    plt.ylabel(&#39;predicted probability&#39;)
    plt.legend()
    plt.show()
    
    
def plot_above_threshold(x1, y1, b1, x2, y2, b2, ax, color, lsty):
    
    sl1 = (y2 - y1)/(x2 - x1)
    sl2 = (b2 - b1)/(x2 - x1)
    if y1 &gt;= b1 and y2 &gt;= b2:
        ax.plot([x1, x2], [y1, y2], linestyle=lsty, color=color, alpha=1)
    elif y1 &lt; b1 and y2 &lt; b2:
        ax.plot([x1, x2], [y1, y2], linestyle=lsty, color=color, alpha=.1) 
    elif y1 &gt;= b1 and y2 &lt; b2:
        crosspoint_x, crosspoint_y = x1 + (y1 - b1)/(sl2 - sl1), y1 + sl1 * (y1 - b1)/(sl2 - sl1)        
        ax.plot([x1, crosspoint_x], [y1, crosspoint_y], linestyle=lsty, color=color, alpha=1)
        ax.plot([crosspoint_x, x2], [crosspoint_y, y2], linestyle=lsty, color=color, alpha=.1)
    elif y1 &lt; b1 and y2 &gt;= b2:
        crosspoint_x, crosspoint_y = x1 + (y1 - b1)/(sl2 - sl1), y1 + sl1 * (y1 - b1)/(sl2 - sl1)        
        ax.plot([x1, crosspoint_x], [y1, crosspoint_y], linestyle=lsty, color=color, alpha=.1)
        ax.plot([crosspoint_x, x2], [crosspoint_y, y2], linestyle=lsty, color=color, alpha=1) 
        
def plot_background(interval, bg, trace, color, ax):
    ax.fill_between(interval * np.arange(len(bg)), 
                                        [0] * len(bg),
                                        2 * np.array(bg), 
                                        alpha=.1,
                                        color=color) 
                        
    x, y, lt = np.arange(len(trace)), np.array(trace), len(trace)
    #ax.plot(interval * x, y, linestyle=&#39;--&#39;, color=cr, alpha=.2)
    bg = 2 * np.array(bg)
    for f in range(lt - 1):
        lsty = &#39;--&#39; if f &lt; 5 or f &gt;= lt - 5 else &#39;-&#39;
        plot_above_threshold(x1=interval*x[f], 
                             y1=y[f], 
                                                 b1=bg[f], 
                                                 x2=interval*x[f+1], 
                                                 y2=y[f+1], 
                                                 b2=bg[f+1], 
                                                 ax=ax, 
                                                 color=color,
                                                 lsty=lsty)
        
def plot_curves(df, extra_key=None, extra_key_label=None,
                hline=True, R=5, C=8,
                xlim=None,
                fig=None, ylim_constant=False, background=False, ylim_cla=None,
                ylim_aux=None, ylim_dyn=None,
                xlim_constant=True, legend=True, plot_x=True,
                yticks=None, yticklabels=None, num_axes=3, show_track_pid=False,
                axes_invisible=False):
    &#39;&#39;&#39;Plot time-series curves from df
    &#39;&#39;&#39;
    DIFF = 0
    if fig is None:
        plt.figure(figsize=(16, 10), dpi=200, facecolor=&#39;white&#39;)
    lifetime_max = np.max(df.lifetime.values[:R * C])
    df = df.iloc[range(R * C)]
    for i in range(R * C):
        if i &lt; df.shape[0]:
            ax = plt.subplot(R, C, i + 1)
            row = df.iloc[i]
            if &#39;1.5s&#39; in row[&#39;cell_num&#39;]:
                interval = 1.5
            else:
                interval = 1
                
            if num_axes == 1:
                if plot_x:
                    plt.plot(interval * np.arange(len(row.X_extended)), np.array(row.X_extended) + DIFF, linestyle=&#39;--&#39;, color=cr)
                    plt.plot(interval * np.arange(len(row.Y_extended)), np.array(row.Y_extended) + DIFF, linestyle=&#39;--&#39;, color=cg)
                    plt.plot(interval * np.arange(5, len(row.X_extended)-5), np.array(row.X_extended)[5:(-5)] + DIFF, color=cr, label=&#39;Clathrin&#39;)
                    plt.plot(interval * np.arange(5, len(row.Y_extended)-5), np.array(row.Y_extended)[5:(-5)] + DIFF, color=cg, label=&#39;Auxilin&#39;)
                    #plt.plot(interval * np.arange(5), np.array(row.X_extended)[-5:] + DIFF, linestyle=&#39;--&#39;, color=cr, label=&#39;Clathrin&#39;)
                    #plt.plot(interval * np.arange(5), np.array(row.Y_extended)[-5:] + DIFF, linestyle=&#39;--&#39;, color=cg, label=&#39;Auxilin&#39;) 
                if background:
                    ax.plot(interval * np.arange(len(row.X_extended)), np.array(row.X_c_extended), 
                        color=cr, linewidth=.8)                
                ax.fill_between(interval * np.arange(len(row.X_extended)),
                                 np.array(row.X_extended) - np.array(row.X_std_extended),
                                 np.array(row.X_extended) + np.array(row.X_std_extended),
                                 alpha=.2,
                                 color=cr
                                 )                    
                if hline:
                    plt.axhline(642.3754691658837, color=&#39;gray&#39;, alpha=0.5)
                if extra_key is not None:
                    if extra_key_label is None:
                        if extra_key == &#39;Z&#39;:
                            extra_key_label = &#39;Dynamin&#39;
                        else:
                            extra_key_label = extra_key
                    plt.plot(interval * np.arange(len(row[extra_key])), np.array(row[extra_key]) + DIFF, linestyle=&#39;--&#39;, color=&#39;gray&#39;)
                    plt.plot(interval * np.arange(5, len(row[extra_key])-5), np.array(row[extra_key])[5:(-5)] + DIFF, color=&#39;gray&#39;, label=extra_key_label)
                if xlim_constant:
                    if xlim is None:
                        plt.xlim([-1, lifetime_max + 1])
                    else:
                        print(xlim)
                        plt.xlim(xlim)
                        
                if ylim_constant:
                    if ylim is None:
                        plt.ylim([-10, max(max(df.X_max), max(df.Y_max)) + 1])
                    else:
                        plt.ylim(ylim[0] + DIFF, ylim[1] + DIFF)
                if yticks is not None:
                        plt.yticks(yticks, labels=yticklabels)
                    
            else:
                ax.spines[&#39;right&#39;].set_visible(True)
                twin1 = ax.twinx()
                if num_axes == 3:
                    twin2 = ax.twinx()
                    twin2.spines[&#39;right&#39;].set_visible(True)
                    twin2.spines[&#39;right&#39;].set_position((&#34;axes&#34;, 1.2))
                else:
                    twin2 = twin1
                if show_track_pid:
                    ax.text(.5, .9, f&#39;{row.pid}&#39;, # row.pid
                            horizontalalignment=&#39;right&#39;,
                            transform=ax.transAxes)                    

                if plot_x:
                    p1, = ax.plot(interval * np.arange(len(row.X_extended)), np.array(row.X_extended) + DIFF, linestyle=&#39;--&#39;, color=cr, alpha=.1)
                    if i == 0:
                        ax.text(x=interval * len(row.X_extended),
                            y=np.array(row.X_extended)[-1],
                            s=&#39;CLTA-TagRFP&#39;,
                            color=cr,
                            size=8)
                    if background:
                        plot_background(interval, row.X_sigma_extended, row.X_extended, color=cr, ax=ax)
                               
                    else:
                        ax.plot(interval * np.arange(5, len(row.X_extended)-5), np.array(row.X_extended)[5:(-5)] + DIFF, color=cr)  
                    if i == 0 and legend:
                        dvu.line_legend()                        
                    ax.fill_between(interval * np.arange(len(row.X_extended)),
                                     np.array(row.X_extended) - np.array(row.X_std_extended),
                                     np.array(row.X_extended) + np.array(row.X_std_extended),
                                     alpha=.2,
                                     color=cr
                                     )  

                    
                    p2, = twin1.plot(interval * np.arange(len(row.Y_extended)), np.array(row.Y_extended) + DIFF, linestyle=&#39;--&#39;, color=cg, alpha=.1)
                    
                    if background:
                        plot_background(interval, row.Y_sigma_extended, row.Y_extended, color=cg, ax=twin1
                                       )
                               
                    else:
                        twin1.plot(interval * np.arange(5, len(row.Y_extended)-5), np.array(row.Y_extended)[5:(-5)] + DIFF, color=cg, label=&#39;EGFP-Aux1-GAK-F6&#39;)                     
                    if i == 0 and legend:
                        dvu.line_legend()                                     
                    twin1.fill_between(interval * np.arange(len(row.Y_extended)),
                                     np.array(row.Y_extended) - np.array(row.Y_std_extended),
                                     np.array(row.Y_extended) + np.array(row.Y_std_extended),
                                     alpha=.2,
                                     color=cg
                                     )  
                    if i == 0:
                        twin1.text(x=interval * len(row.Y_extended),
                              y=np.array(row.Y_extended)[-1],
                              s=&#39;EGFP-Aux1-GAK-F6&#39;,
                              color=cg,
                              size=8)                    
                    #plt.plot(interval * np.arange(5), np.array(row.X_extended)[-5:] + DIFF, linestyle=&#39;--&#39;, color=cr, label=&#39;Clathrin&#39;)
                    #plt.plot(interval * np.arange(5), np.array(row.Y_extended)[-5:] + DIFF, linestyle=&#39;--&#39;, color=cg, label=&#39;Auxilin&#39;) 
                    if hline:
                        ax.axhline(642.3754691658837, color=&#39;gray&#39;, alpha=0.5)
                if extra_key is not None:
                    if extra_key_label is None:
                        if extra_key == &#39;Z&#39;:
                            extra_key_label = &#39;Dynamin&#39;
                        else:
                            extra_key_label = extra_key
                    p3, = twin2.plot(interval * np.arange(len(row.Z_extended)), np.array(row.Z_extended) + DIFF, linestyle=&#39;--&#39;, color=&#39;gray&#39;, alpha=.1)
                    
                    if background:
                        plot_background(interval, row.Z_sigma_extended, row.Z_extended, color=&#39;gray&#39;, ax=twin2)
                               
                    else:
                        twin2.plot(interval * np.arange(5, len(row.Z_extended)-5), np.array(row.Z_extended)[5:(-5)] + DIFF, color=&#39;gray&#39;)
                    twin2.fill_between(interval * np.arange(len(row.Z_extended)),
                                     np.array(row.Z_extended) - np.array(row.Z_std_extended),
                                     np.array(row.Z_extended) + np.array(row.Z_std_extended),
                                     alpha=.1,
                                     color=&#39;gray&#39;
                                     )
                    if i == 0:
                        twin2.text(x=interval * len(row.Z_extended),
                              y=np.array(row.Z_extended)[-1]-500,
                              s=&#39;Dyn2-Halo-E1-JF646&#39;,
                              color=&#39;gray&#39;,
                              size=8)                    
                    #if i == 0 and legend:
                    #    dvu.line_legend()                    
                tkw = dict(size=4, width=1.5)
                ax.spines[&#39;right&#39;].set_color(cg)
                ax.tick_params(axis=&#39;y&#39;, colors=cr, labelsize=6, **tkw)
                twin1.spines[&#39;left&#39;].set_color(cr)
                ax.spines[&#39;left&#39;].set_color(cr)
                #twin1.spines[&#39;left&#39;].set_color(cg)
                if num_axes == 3:
                    twin2.spines[&#39;left&#39;].set_color(cr)
                    twin2.spines[&#39;right&#39;].set_color(p3.get_color())  
                    twin2.tick_params(axis=&#39;y&#39;, colors=p3.get_color(), labelsize=6, **tkw)
                if ylim_constant:
                    ax.set_ylim(ylim_cla)
                    twin1.set_ylim(ylim_aux)
                    twin2.set_ylim(ylim_dyn)
                else:
                    #p1_ylim = ax.get_ylim()
                    p2_ylim = twin1.get_ylim()                    
                    p3_ylim = twin2.get_ylim()
                    ylim_min = min(p2_ylim[0], p3_ylim[0])
                    twin1.set_ylim((ylim_min, 2*p2_ylim[1]))
                    twin2.set_ylim((ylim_min, 3*p3_ylim[1]))   
                
                p1_ylim = ax.get_ylim() 
                ax.set_ylim((- 2 * p1_ylim[1], p1_ylim[1])) 
                
                p2_ylim = twin1.get_ylim() 
                twin1.set_ylim((- 0.5 * p2_ylim[1], p2_ylim[1])) 
                
                #p3_ylim = twin2.get_ylim() 
                #twin1.set_ylim((- 0.5 * p3_ylim[1], p3_ylim[1]))  
                
                twin1.tick_params(axis=&#39;y&#39;, colors=cg, labelsize=6, **tkw)
                
                ax.tick_params(axis=&#39;x&#39;, **tkw)
                yticks = ax.get_yticks()
                #if len(yticks) &gt; 5:
                ax.set_yticks([yt for yt in yticks if yt &gt;= 0])
                
                yticks = twin1.get_yticks()
                #if len(yticks) &gt; 5:
                twin1.set_yticks(yticks[np.arange(1, len(yticks), 2)])
                if num_axes == 3:
                    yticks = twin2.get_yticks()
                    if len(yticks) &gt; 5:
                        twin2.set_yticks(yticks[np.arange(1, len(yticks), 2)])                   
                if xlim_constant:
                    if xlim is None:
                        plt.xlim([-1, lifetime_max + 16])
                    else:
                        print(xlim)
                        plt.xlim(xlim)
                
                if axes_invisible:
                    ax.yaxis.set_visible(False)
                    ax.xaxis.set_visible(False)
                    twin1.yaxis.set_visible(False)
                    twin1.spines[&#39;left&#39;].set_color(&#39;w&#39;)
                    twin2.spines[&#39;left&#39;].set_color(&#39;w&#39;)
                    twin2.yaxis.set_visible(False)
                    twin1.spines[&#39;right&#39;].set_color(&#39;w&#39;)
                    twin2.spines[&#39;right&#39;].set_color(&#39;w&#39;)
                
                                
            #plt.yscale(&#39;log&#39;)                  
            

    #     plt.axi(&#39;off&#39;)

            
#         plt.legend()

    plt.tight_layout()
    if fig is None:
        plt.show()        


def viz_errs_outliers_venn(X_test, preds, Y_test, num_feats_reduced=5):
    &#39;&#39;&#39;Compare outliers to errors in venn-diagram
    &#39;&#39;&#39;
    feat_names = data.get_feature_names(X_test)
    X_feat = X_test[feat_names]

    if num_feats_reduced is not None:
        pca = decomposition.PCA(n_components=num_feats_reduced)
        X_reduced = pca.fit_transform(X_feat)
    else:
        X_reduced = X_feat

    R, C = 2, 2
    titles = [&#39;isolation forest&#39;, &#39;local outlier factor&#39;, &#39;elliptic envelop&#39;, &#39;one-class svm&#39;]
    plt.figure(figsize=(6, 5), dpi=200)
    for i in range(4):
        plt.subplot(R, C, i + 1)
        plt.title(titles[i])
        if i == 0:
            clf = IsolationForest(n_estimators=10, warm_start=True)
        elif i == 1:
            clf = LocalOutlierFactor(novelty=True)
        elif i == 2:
            clf = EllipticEnvelope()
        elif i == 3:
            clf = OneClassSVM()
        clf.fit(X_reduced)  # fit 10 trees  
        is_outlier = clf.predict(X_reduced) == -1
        is_err = preds != Y_test
        idxs = np.arange(is_outlier.size)
        venn2([set(idxs[is_outlier]), set(idxs[is_err])], set_labels=[&#39;outliers&#39;, &#39;errors&#39;])


def plot_pcs(pca, X):
    &#39;&#39;&#39;Pretty plot of pcs with explained var bars
    Params
    ------
    pca: sklearn PCA class after being fitted
    &#39;&#39;&#39;
    plt.figure(figsize=(6, 9), dpi=200)

    # extract out relevant pars
    comps = pca.components_.transpose()
    var_norm = pca.explained_variance_ / np.sum(pca.explained_variance_) * 100

    # create a 2 X 2 grid 
    gs = grd.GridSpec(2, 2, height_ratios=[2, 10],
                      width_ratios=[12, 1], wspace=0.1, hspace=0)

    # plot explained variance
    ax2 = plt.subplot(gs[0])
    ax2.bar(np.arange(0, comps.shape[1]), var_norm,
            color=&#39;gray&#39;, width=0.8)
    plt.title(&#39;Explained variance (%)&#39;)
    ax2.spines[&#39;right&#39;].set_visible(False)
    ax2.spines[&#39;top&#39;].set_visible(False)
    ax2.yaxis.set_ticks_position(&#39;left&#39;)
    ax2.set_yticks([0, max(var_norm)])
    plt.xlim((-0.5, comps.shape[1] - 0.5))

    # plot pcs
    ax = plt.subplot(gs[2])
    vmaxabs = np.max(np.abs(comps))
    p = ax.imshow(comps, interpolation=&#39;None&#39;, aspect=&#39;auto&#39;,
                  cmap=sns.diverging_palette(10, 240, as_cmap=True, center=&#39;light&#39;),
                  vmin=-vmaxabs, vmax=vmaxabs)  # center at 0
    plt.xlabel(&#39;PCA component number&#39;)
    ax.set_yticklabels(list(X))
    ax.set_yticks(range(len(list(X))))

    # make colorbar
    colorAx = plt.subplot(gs[3])
    cb = plt.colorbar(p, cax=colorAx)
    plt.show()


def print_metadata(acc=None, metadata_file=oj(config.DIR_PROCESSED, &#39;metadata_clath_aux+gak_a7d2.pkl&#39;)):
    m = pkl.load(open(metadata_file, &#39;rb&#39;))

    print(
        f&#39;valid:\t\t{m[&#34;num_aux_pos_valid&#34;]:&gt;4.0f} aux+ / {m[&#34;num_tracks_valid&#34;]:&gt;4.0f} ({m[&#34;num_aux_pos_valid&#34;] / m[&#34;num_tracks_valid&#34;]:.3f})&#39;)
    print(&#39;----------------------------------------&#39;)
    print(f&#39;hotspots:\t{m[&#34;num_hotspots_valid&#34;]:&gt;4.0f} aux+ / {m[&#34;num_hotspots_valid&#34;]:&gt;4.0f}&#39;)
    print(
        f&#39;short:\t\t{m[&#34;num_short&#34;] - m[&#34;num_short&#34;] * m[&#34;acc_short&#34;]:&gt;4.0f} aux+ / {m[&#34;num_short&#34;]:&gt;4.0f} ({m[&#34;acc_short&#34;]:.3f})&#39;)
    print(f&#39;long:\t\t{m[&#34;num_long&#34;] * m[&#34;acc_long&#34;]:&gt;4.0f} aux+ / {m[&#34;num_long&#34;]:&gt;4.0f} ({m[&#34;acc_long&#34;]:.3f})&#39;)
    print(
        f&#39;hard:\t\t{m[&#34;num_aux_pos_hard&#34;]:&gt;4.0f} aux+ / {m[&#34;num_tracks_hard&#34;]:&gt;4.0f} ({m[&#34;num_aux_pos_hard&#34;] / m[&#34;num_tracks_hard&#34;]:.3f})&#39;)

    if acc is not None:
        print(&#39;----------------------------------------&#39;)
        print(f&#39;hard acc:\t\t\t  {acc:.3f}&#39;)
        num_eval = m[&#34;num_tracks_valid&#34;] - m[&#34;num_hotspots_valid&#34;]
    #         print(
    #             f&#39;total acc (no hotspots):\t  {(m[&#34;num_short&#34;] * m[&#34;acc_short&#34;] + m[&#34;num_long&#34;] * m[&#34;acc_long&#34;] + acc * m[&#34;num_tracks_hard&#34;]) / num_eval:.3f}&#39;)
    print(&#39;\nlifetime threshes&#39;, m[&#39;thresh_short&#39;], m[&#39;thresh_long&#39;])


def jointplot_grouped(col_x: str, col_y: str, col_k: str, df,
                      k_is_color=False, scatter_alpha=.5, add_global_hists: bool = False, ms=None):
    &#39;&#39;&#39;Jointplot of hists + densities
    Params
    ------
    col_x
        name of X var
    col_y
        name of Y var
    col_k
        name of variable to group/color by
    add_global_hists
        whether to plot the global hist as well
    &#39;&#39;&#39;

    def colored_scatter(x, y, c=None):
        def scatter(*args, **kwargs):
            args = (x, y)
            if c is not None:
                kwargs[&#39;c&#39;] = c
            kwargs[&#39;marker&#39;] = &#39;.&#39;
            kwargs[&#39;alpha&#39;] = scatter_alpha
            plt.scatter(*args, **kwargs)

        return scatter

    g = sns.JointGrid(
        x=col_x,
        y=col_y,
        data=df
    )
    color = None
    legends = []
    for name, df_group in df.groupby(col_k):
        legends.append(name)
        if k_is_color:
            color = name
        g.plot_joint(
            colored_scatter(df_group[col_x], df_group[col_y], color),
        )
        sns.distplot(
            df_group[col_x].values,
            ax=g.ax_marg_x,
            color=color,
        )
        sns.distplot(
            df_group[col_y].values,
            ax=g.ax_marg_y,
            color=color,
            vertical=True
        )
    if add_global_hists:
        sns.distplot(
            df[col_x].values,
            ax=g.ax_marg_x,
            color=&#39;grey&#39;
        )
        sns.distplot(
            df[col_y].values.ravel(),
            ax=g.ax_marg_y,
            color=&#39;grey&#39;,
            vertical=True
        )
    plt.legend(legends)


# 2d decision boundary
def plot_decision_boundary(X_col, Y_col, m, df, norms, num_pts=100):
    &#39;&#39;&#39;still not finished...
    &#39;&#39;&#39;
    x = df[X_col]
    y = df[Y_col]
    x = np.linspace(x.min(), x.max(), num_pts)
    y = np.linspace(y.min(), y.max(), num_pts)

    # normalize
    xv, yv = np.meshgrid(x, y, indexing=&#39;ij&#39;)
    x = xv.flatten()
    y = yv.flatten()
    x = (x - norms[X_col][&#39;mu&#39;]) / (norms[X_col][&#39;std&#39;])
    y = (y - norms[Y_col][&#39;mu&#39;]) / (norms[Y_col][&#39;std&#39;])

    X = np.hstack((x, y)).reshape(-1, 2)
    print(X.shape)

    X = df[results_individual[&#39;feat_names_selected&#39;]]

    preds = m.predict(X)


def cumulative_acc_plot_hard(preds_proba, preds, y_full_cv):
    args = np.argsort(np.abs(preds_proba - 0.5))[::-1]
    accs = (preds == y_full_cv)[args]
    n = accs.size
    accs = np.cumsum(accs) / np.arange(1, n + 1)

    plt.figure(dpi=500)
    plt.plot(preds_proba[args], &#39;.&#39;, ms=0.5, label=&#39;predicted prob&#39;, color=cb)
    plt.plot(accs, label=&#39;cumulative acc&#39;, color=cr)
    plt.yticks(np.arange(-0.05, 1.05, 0.1))
    plt.xlabel(&#39;num pts included&#39;)
    plt.grid(alpha=0.2)
    plt.legend()
    plt.show()


def cumulative_acc_plot_all(df, pred_proba_key=&#39;preds_proba&#39;, pred_key=&#39;preds&#39;,
                            outcome_def=&#39;y_consec_thresh&#39;,
                            plot_vert_line_for_high_lifetimes=False, show=True):
    plt.figure(dpi=500)
    ax = plt.subplot(111)
    
    # full (no model)
    argsf = np.argsort(df.lifetime.values)
    accsf = (1 - df[outcome_def]).values[argsf]
    n = df.shape[0]
    plt.plot(np.cumsum(accsf) / np.arange(1, accsf.size + 1), label=&#39;Predicting all abortive&#39;, color=&#39;gray&#39;)
    print(&#39;accsf&#39;, np.sum(accsf))
    
    # short
    ds = df[df.short]
    argss = np.argsort(ds.lifetime.values)
    accss = (1 - ds[outcome_def]).values[argss]
    ns = ds.shape[0]
    # hard
    dh = df[~df.short]
    argsh = np.argsort(np.abs(dh[pred_key])) #[::-1]
    accsh = ((dh[pred_key].values &gt; 0) == dh[outcome_def].values)[argsh]
    # put things together
    accs = np.hstack((accss, accsh))
    print(accsf.shape, accss.shape, accsh.shape, accs.shape)
    plt.plot(np.cumsum(accs) / np.arange(1, accs.size + 1), label=&#39;LSTM&#39;, color=cb)
    print(accs)
    plt.axvline(ns, lw=2.5, color=&#39;black&#39;)
    
#     dvu.line_legend()
    plt.xlabel(&#39;Percentage of tracks included (sorted by uncertainty)&#39;)
    plt.ylabel(&#39;Accuracy&#39;)
    ax.xaxis.set_ticks([int(x) for x in np.arange(0, n + 1, n//5)])
    ax.xaxis.set_ticklabels([str(int(x)) + &#39;%&#39; for x in np.arange(0, 101, 100/5)])
    plt.legend(fontsize=&#39;x-large&#39;, frameon=False, labelcolor=&#39;linecolor&#39;)
    
    plt.grid(alpha=0.2)
    plt.tight_layout()

def plot_example(ex):
    &#39;&#39;&#39;ex - row of the dataframe
    &#39;&#39;&#39;
    plt.figure(dpi=200)
    plt.plot(ex[&#39;X&#39;], color=&#39;red&#39;, label=&#39;clathrin&#39;)
    plt.plot(ex[&#39;Y&#39;], color=&#39;green&#39;, label=&#39;auxilin&#39;)
    plt.xlabel(&#39;Time&#39;)
    plt.ylabel(&#39;Amplitude&#39;)
    plt.legend()
    
def get_videos(cell_dir: str):
    &#39;&#39;&#39;Loads in X and Y for one cell
    
    Params
    ------
    cell_dir
        Path to directory for one cell
    
    Returns
    -------
    videos
    &#39;&#39;&#39;
    fname = {&#39;cla&#39;: &#39;TagRFP&#39;, &#39;aux&#39;: &#39;EGFP&#39;, &#39;dyn&#39;: &#39;JF646&#39;}
    videos = {}
    
    for m in fname:
        for name in os.listdir(oj(cell_dir, fname[m])):
        #print(f&#34;filename: {name}&#34;)
            if &#39;tif&#39; in name:
                videos[m] = imread(oj(cell_dir, fname[m], name))

    return videos
    
def get_all_dynamin_videos(cells):
    
    all_videos = {}
    upper_dir = oj(&#39;/scratch/users/vision/data/abc_data/dynamin_data_with_ims/&#39;,
               &#39;CLTA-TagRFP EGFP-Aux1-GAK-F6 Dyn2-Halo-E1-JF646&#39;)
    for cell_num in cells:
        cell_dir = cell_num[:-6] + &#39;Cell1_1.5s&#39;
        full_dir = oj(upper_dir, cell_dir)
        all_videos[cell_num] = get_videos(full_dir)
    return all_videos

def get_dynamin_data_videos(df, pids, add_px=2, apply_norm=True):
    
    &#34;&#34;&#34;
    extract videos of dynamin traces 
    
    Params:
    ------
    df: pd.DataFrame
        dataframe
    
    pids: list
        list of pids to plot
        
    add_px: int
        number of additional pixels in each direction
        add_px=1 means 3*3 pixels around the center, add_px=2 means 5*5, etc.
        
    Returns:
    ------
    videos
    
    &#34;&#34;&#34;
    
    indices = np.array([np.where(df.pid.values == pid)[0][0] for pid in pids])
    df = df.iloc[indices]
    cells = set(df.cell_num.values)
    raw_videos = get_all_dynamin_videos(cells)
    
    videos = {}
    
    for i in range(len(df)):
        
        cell_num = df.cell_num.iloc[i]
        fr, h, w = raw_videos[cell_num][&#39;cla&#39;].shape
        pid = df.pid.iloc[i]
        videos[pid] = {}
        x_pos, y_pos = df.x_pos_seq.iloc[i], df.y_pos_seq.iloc[i]
        x_pos = [x_pos[0]]*5 + x_pos + [x_pos[-1]]*5
        y_pos = [y_pos[0]]*5 + y_pos + [y_pos[-1]]*5
        t, lt = df.t.iloc[i] - 5*1.5, min(len(x_pos), len(y_pos))                
        for m in [&#39;cla&#39;, &#39;aux&#39;, &#39;dyn&#39;]:
            videos[pid][m] = []
            
        for j in range(lt):
            for m in [&#39;cla&#39;, &#39;aux&#39;, &#39;dyn&#39;]:
                crop_y_pos = np.maximum(0, np.minimum(h - 1, np.arange(int(y_pos[j]) - add_px, int(y_pos[j]) + add_px + 1)))
                crop_x_pos = np.maximum(0, np.minimum(h - 1, np.arange(int(x_pos[j]) - add_px, int(x_pos[j]) + add_px + 1)))
                videos[pid][m].append(raw_videos[cell_num][m][int(t/1.5) + j,:,:] \
                            [crop_y_pos, :] \
                            [:, crop_x_pos])
            
                # normalize by the min/max intensities
                #vmin, vmax = raw_videos[cell_num][m][int(t/1.5) + j,:,:].mean(), raw_videos[cell_num][m][int(t/1.5) + j,:,:].max()
                #videos[pid][m][-1] = (videos[pid][m][-1] - vmin)/(vmax - vmin)
    
    # normalization
    norm = {}
    for m in [&#39;cla&#39;, &#39;aux&#39;, &#39;dyn&#39;]:
        norm[m] = [1e9, -1e9] # min, max
        for pid in videos:
            for j in range(len(videos[pid][m])):
                norm[m][0] = min(norm[m][0], videos[pid][m][j].min())
                norm[m][1] = max(norm[m][1], videos[pid][m][j].max())
    
    if apply_norm:
        for pid in videos:
            for m in [&#39;cla&#39;, &#39;aux&#39;, &#39;dyn&#39;]:
                for j in range(len(videos[pid][m])):
                    videos[pid][m][j] = (videos[pid][m][j] - norm[m][0])/(norm[m][1] - norm[m][0])
            
            
    return videos, norm
    

def plot_kymographs(df, pids, add_px=2):
    
    &#34;&#34;&#34;
    plot kymographs of dynamin traces 
    
    Params:
    ------
    df: pd.DataFrame
        dataframe
    
    pids: list
        list of pids to plot
        
    add_px: int
        number of additional pixels in each direction
        add_px=1 means 3*3 pixels around the center, add_px=2 means 5*5, etc.
        
    Returns:
    ------
    cla_traces: np.array
        clathrin traces from raw images
    aux_traces: np.array
        auxilin traces from raw images
    rgb_image: 3d np.array
        3d array (RGB values) of kymographs
    &#34;&#34;&#34;
    
    indices = np.array([np.where(df.pid.values == pid)[0][0] for pid in pids])
    df = df.iloc[indices]
    cells = set(df.cell_num.values)
    raw_videos = get_all_dynamin_videos(cells)
    viridis = cm.get_cmap(&#39;viridis&#39;, 12)
    reds = cm.get_cmap(&#39;Reds&#39;, 12) # red palette for clathrin
    greens = cm.get_cmap(&#39;Greens&#39;, 12) # green palette for auxilin
    
    lmax = max([len(df.x_pos_seq.iloc[i]) for i in range(len(df))]) + 2
    width = 2 * add_px + 1
    cla_traces, aux_traces = {}, {}
    
    for i in range(len(df)):
        cla_traces[i], aux_traces[i] = np.zeros((lmax, width)), np.zeros((lmax, width))
        #xmean = X[df.cell_num.iloc[i]].mean()
        cell_num = df.cell_num.iloc[i]
        x_pos, y_pos = df.x_pos_seq.iloc[i], df.y_pos_seq.iloc[i]
        t, lt = df.t.iloc[i], min(len(x_pos), len(y_pos))        
        
        for k in range(-add_px, add_px + 1):
            for j in range(lt):
                video = raw_videos[cell_num][&#39;cla&#39;]
                cla_traces[i][j, k + add_px] = max(video[int(t/1.5) + j, \
                                                      range(int(y_pos[j]) - 0, int(y_pos[j]) + 0 + 1), \
                                                      int(x_pos[j] + k)])
                vmin, vmax = video[int(t/1.5) + j,:,:].min(), video[int(t/1.5) + j,:,:].max()
                cla_traces[i][j, k + add_px] = (cla_traces[i][j, k + add_px] - vmin)/(vmax - vmin)
                
                video = raw_videos[cell_num][&#39;aux&#39;]
                aux_traces[i][j, k + add_px] = max(video[int(t/1.5) + j, \
                                                      range(int(y_pos[j]) - 0, int(y_pos[j]) + 0 + 1), \
                                                      int(x_pos[j] + k)])
                vmin, vmax = video[int(t/1.5) + j,:,:].min(), video[int(t/1.5) + j,:,:].max()
                aux_traces[i][j, k + add_px] = (aux_traces[i][j, k + add_px] - vmin)/(vmax - vmin)                
    
    ncol = 3 * width * len(df)
    cla_sparse = np.zeros((lmax, ncol))
    aux_sparse = np.zeros((lmax, ncol))
    for i in range(len(df)):
        start_index = 3 * width * i
        cla_sparse[:, (start_index):(start_index + width)] = cla_traces[i]
        aux_sparse[:, (start_index + width):(start_index + 2 * width)] = aux_traces[i]
    
    rgb_image = np.array([[list(reds(cla_sparse[i][j])[:3])
                      #[1, 1 - cla_sparse[i][j], 1 - cla_sparse[i][j]] \
                      if 0 &lt; cla_sparse[i][j] &lt; 1 \
                      else \
                      list(greens(aux_sparse[i][j])[:3]) \
                      #[1 - aux_sparse[i][j], 1, 1 - aux_sparse[i][j]] \
                      if 0 &lt; aux_sparse[i][j] &lt; 1 \
                      #else list(viridis(np.random.choice(background, 1)[0])[:3])\
                      else (1, 1, 1)
                      for i in range(lmax)] \
                      for j in range(ncol)])
    #cla_sparse = np.transpose(cla_sparse)
    #aux_sparse = np.transpose(aux_sparse)
    return cla_traces, aux_traces, rgb_image</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="src.viz.cumulative_acc_plot_all"><code class="name flex">
<span>def <span class="ident">cumulative_acc_plot_all</span></span>(<span>df, pred_proba_key='preds_proba', pred_key='preds', outcome_def='y_consec_thresh', plot_vert_line_for_high_lifetimes=False, show=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cumulative_acc_plot_all(df, pred_proba_key=&#39;preds_proba&#39;, pred_key=&#39;preds&#39;,
                            outcome_def=&#39;y_consec_thresh&#39;,
                            plot_vert_line_for_high_lifetimes=False, show=True):
    plt.figure(dpi=500)
    ax = plt.subplot(111)
    
    # full (no model)
    argsf = np.argsort(df.lifetime.values)
    accsf = (1 - df[outcome_def]).values[argsf]
    n = df.shape[0]
    plt.plot(np.cumsum(accsf) / np.arange(1, accsf.size + 1), label=&#39;Predicting all abortive&#39;, color=&#39;gray&#39;)
    print(&#39;accsf&#39;, np.sum(accsf))
    
    # short
    ds = df[df.short]
    argss = np.argsort(ds.lifetime.values)
    accss = (1 - ds[outcome_def]).values[argss]
    ns = ds.shape[0]
    # hard
    dh = df[~df.short]
    argsh = np.argsort(np.abs(dh[pred_key])) #[::-1]
    accsh = ((dh[pred_key].values &gt; 0) == dh[outcome_def].values)[argsh]
    # put things together
    accs = np.hstack((accss, accsh))
    print(accsf.shape, accss.shape, accsh.shape, accs.shape)
    plt.plot(np.cumsum(accs) / np.arange(1, accs.size + 1), label=&#39;LSTM&#39;, color=cb)
    print(accs)
    plt.axvline(ns, lw=2.5, color=&#39;black&#39;)
    
#     dvu.line_legend()
    plt.xlabel(&#39;Percentage of tracks included (sorted by uncertainty)&#39;)
    plt.ylabel(&#39;Accuracy&#39;)
    ax.xaxis.set_ticks([int(x) for x in np.arange(0, n + 1, n//5)])
    ax.xaxis.set_ticklabels([str(int(x)) + &#39;%&#39; for x in np.arange(0, 101, 100/5)])
    plt.legend(fontsize=&#39;x-large&#39;, frameon=False, labelcolor=&#39;linecolor&#39;)
    
    plt.grid(alpha=0.2)
    plt.tight_layout()</code></pre>
</details>
</dd>
<dt id="src.viz.cumulative_acc_plot_hard"><code class="name flex">
<span>def <span class="ident">cumulative_acc_plot_hard</span></span>(<span>preds_proba, preds, y_full_cv)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cumulative_acc_plot_hard(preds_proba, preds, y_full_cv):
    args = np.argsort(np.abs(preds_proba - 0.5))[::-1]
    accs = (preds == y_full_cv)[args]
    n = accs.size
    accs = np.cumsum(accs) / np.arange(1, n + 1)

    plt.figure(dpi=500)
    plt.plot(preds_proba[args], &#39;.&#39;, ms=0.5, label=&#39;predicted prob&#39;, color=cb)
    plt.plot(accs, label=&#39;cumulative acc&#39;, color=cr)
    plt.yticks(np.arange(-0.05, 1.05, 0.1))
    plt.xlabel(&#39;num pts included&#39;)
    plt.grid(alpha=0.2)
    plt.legend()
    plt.show()</code></pre>
</details>
</dd>
<dt id="src.viz.fix_feat_name"><code class="name flex">
<span>def <span class="ident">fix_feat_name</span></span>(<span>s)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fix_feat_name(s):
    return s.replace(&#39;_&#39;, &#39; &#39;).replace(&#39;X&#39;, &#39;Clath&#39;).capitalize()</code></pre>
</details>
</dd>
<dt id="src.viz.get_all_dynamin_videos"><code class="name flex">
<span>def <span class="ident">get_all_dynamin_videos</span></span>(<span>cells)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_dynamin_videos(cells):
    
    all_videos = {}
    upper_dir = oj(&#39;/scratch/users/vision/data/abc_data/dynamin_data_with_ims/&#39;,
               &#39;CLTA-TagRFP EGFP-Aux1-GAK-F6 Dyn2-Halo-E1-JF646&#39;)
    for cell_num in cells:
        cell_dir = cell_num[:-6] + &#39;Cell1_1.5s&#39;
        full_dir = oj(upper_dir, cell_dir)
        all_videos[cell_num] = get_videos(full_dir)
    return all_videos</code></pre>
</details>
</dd>
<dt id="src.viz.get_dynamin_data_videos"><code class="name flex">
<span>def <span class="ident">get_dynamin_data_videos</span></span>(<span>df, pids, add_px=2, apply_norm=True)</span>
</code></dt>
<dd>
<section class="desc"><p>extract videos of dynamin traces </p>
<h2 id="params">Params:</h2>
<p>df: pd.DataFrame
dataframe</p>
<p>pids: list
list of pids to plot</p>
<p>add_px: int
number of additional pixels in each direction
add_px=1 means 3<em>3 pixels around the center, add_px=2 means 5</em>5, etc.</p>
<h2 id="returns">Returns:</h2>
<p>videos</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dynamin_data_videos(df, pids, add_px=2, apply_norm=True):
    
    &#34;&#34;&#34;
    extract videos of dynamin traces 
    
    Params:
    ------
    df: pd.DataFrame
        dataframe
    
    pids: list
        list of pids to plot
        
    add_px: int
        number of additional pixels in each direction
        add_px=1 means 3*3 pixels around the center, add_px=2 means 5*5, etc.
        
    Returns:
    ------
    videos
    
    &#34;&#34;&#34;
    
    indices = np.array([np.where(df.pid.values == pid)[0][0] for pid in pids])
    df = df.iloc[indices]
    cells = set(df.cell_num.values)
    raw_videos = get_all_dynamin_videos(cells)
    
    videos = {}
    
    for i in range(len(df)):
        
        cell_num = df.cell_num.iloc[i]
        fr, h, w = raw_videos[cell_num][&#39;cla&#39;].shape
        pid = df.pid.iloc[i]
        videos[pid] = {}
        x_pos, y_pos = df.x_pos_seq.iloc[i], df.y_pos_seq.iloc[i]
        x_pos = [x_pos[0]]*5 + x_pos + [x_pos[-1]]*5
        y_pos = [y_pos[0]]*5 + y_pos + [y_pos[-1]]*5
        t, lt = df.t.iloc[i] - 5*1.5, min(len(x_pos), len(y_pos))                
        for m in [&#39;cla&#39;, &#39;aux&#39;, &#39;dyn&#39;]:
            videos[pid][m] = []
            
        for j in range(lt):
            for m in [&#39;cla&#39;, &#39;aux&#39;, &#39;dyn&#39;]:
                crop_y_pos = np.maximum(0, np.minimum(h - 1, np.arange(int(y_pos[j]) - add_px, int(y_pos[j]) + add_px + 1)))
                crop_x_pos = np.maximum(0, np.minimum(h - 1, np.arange(int(x_pos[j]) - add_px, int(x_pos[j]) + add_px + 1)))
                videos[pid][m].append(raw_videos[cell_num][m][int(t/1.5) + j,:,:] \
                            [crop_y_pos, :] \
                            [:, crop_x_pos])
            
                # normalize by the min/max intensities
                #vmin, vmax = raw_videos[cell_num][m][int(t/1.5) + j,:,:].mean(), raw_videos[cell_num][m][int(t/1.5) + j,:,:].max()
                #videos[pid][m][-1] = (videos[pid][m][-1] - vmin)/(vmax - vmin)
    
    # normalization
    norm = {}
    for m in [&#39;cla&#39;, &#39;aux&#39;, &#39;dyn&#39;]:
        norm[m] = [1e9, -1e9] # min, max
        for pid in videos:
            for j in range(len(videos[pid][m])):
                norm[m][0] = min(norm[m][0], videos[pid][m][j].min())
                norm[m][1] = max(norm[m][1], videos[pid][m][j].max())
    
    if apply_norm:
        for pid in videos:
            for m in [&#39;cla&#39;, &#39;aux&#39;, &#39;dyn&#39;]:
                for j in range(len(videos[pid][m])):
                    videos[pid][m][j] = (videos[pid][m][j] - norm[m][0])/(norm[m][1] - norm[m][0])
            
            
    return videos, norm</code></pre>
</details>
</dd>
<dt id="src.viz.get_videos"><code class="name flex">
<span>def <span class="ident">get_videos</span></span>(<span>cell_dir)</span>
</code></dt>
<dd>
<section class="desc"><p>Loads in X and Y for one cell</p>
<h2 id="params">Params</h2>
<dl>
<dt><strong><code>cell_dir</code></strong></dt>
<dd>Path to directory for one cell</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>videos</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_videos(cell_dir: str):
    &#39;&#39;&#39;Loads in X and Y for one cell
    
    Params
    ------
    cell_dir
        Path to directory for one cell
    
    Returns
    -------
    videos
    &#39;&#39;&#39;
    fname = {&#39;cla&#39;: &#39;TagRFP&#39;, &#39;aux&#39;: &#39;EGFP&#39;, &#39;dyn&#39;: &#39;JF646&#39;}
    videos = {}
    
    for m in fname:
        for name in os.listdir(oj(cell_dir, fname[m])):
        #print(f&#34;filename: {name}&#34;)
            if &#39;tif&#39; in name:
                videos[m] = imread(oj(cell_dir, fname[m], name))

    return videos</code></pre>
</details>
</dd>
<dt id="src.viz.highlight_max"><code class="name flex">
<span>def <span class="ident">highlight_max</span></span>(<span>data, color='#0e5c99')</span>
</code></dt>
<dd>
<section class="desc"><p>highlight the maximum in a Series or DataFrame</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def highlight_max(data, color=&#39;#0e5c99&#39;):
    &#39;&#39;&#39;
    highlight the maximum in a Series or DataFrame
    &#39;&#39;&#39;
    attr = &#39;background-color: {}&#39;.format(color)
    if data.ndim == 1:  # Series from .apply(axis=0) or axis=1
        is_max = data == data.max()
        return [attr if v else &#39;&#39; for v in is_max]
    else:  # from .apply(axis=None)
        is_max = data == data.max().max()
        return pd.DataFrame(np.where(is_max, attr, &#39;&#39;),
                            index=data.index, columns=data.columns)</code></pre>
</details>
</dd>
<dt id="src.viz.jointplot_grouped"><code class="name flex">
<span>def <span class="ident">jointplot_grouped</span></span>(<span>col_x, col_y, col_k, df, k_is_color=False, scatter_alpha=0.5, add_global_hists=False, ms=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Jointplot of hists + densities
Params</p>
<hr>
<dl>
<dt><strong><code>col_x</code></strong></dt>
<dd>name of X var</dd>
<dt><strong><code>col_y</code></strong></dt>
<dd>name of Y var</dd>
<dt><strong><code>col_k</code></strong></dt>
<dd>name of variable to group/color by</dd>
<dt><strong><code>add_global_hists</code></strong></dt>
<dd>whether to plot the global hist as well</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jointplot_grouped(col_x: str, col_y: str, col_k: str, df,
                      k_is_color=False, scatter_alpha=.5, add_global_hists: bool = False, ms=None):
    &#39;&#39;&#39;Jointplot of hists + densities
    Params
    ------
    col_x
        name of X var
    col_y
        name of Y var
    col_k
        name of variable to group/color by
    add_global_hists
        whether to plot the global hist as well
    &#39;&#39;&#39;

    def colored_scatter(x, y, c=None):
        def scatter(*args, **kwargs):
            args = (x, y)
            if c is not None:
                kwargs[&#39;c&#39;] = c
            kwargs[&#39;marker&#39;] = &#39;.&#39;
            kwargs[&#39;alpha&#39;] = scatter_alpha
            plt.scatter(*args, **kwargs)

        return scatter

    g = sns.JointGrid(
        x=col_x,
        y=col_y,
        data=df
    )
    color = None
    legends = []
    for name, df_group in df.groupby(col_k):
        legends.append(name)
        if k_is_color:
            color = name
        g.plot_joint(
            colored_scatter(df_group[col_x], df_group[col_y], color),
        )
        sns.distplot(
            df_group[col_x].values,
            ax=g.ax_marg_x,
            color=color,
        )
        sns.distplot(
            df_group[col_y].values,
            ax=g.ax_marg_y,
            color=color,
            vertical=True
        )
    if add_global_hists:
        sns.distplot(
            df[col_x].values,
            ax=g.ax_marg_x,
            color=&#39;grey&#39;
        )
        sns.distplot(
            df[col_y].values.ravel(),
            ax=g.ax_marg_y,
            color=&#39;grey&#39;,
            vertical=True
        )
    plt.legend(legends)</code></pre>
</details>
</dd>
<dt id="src.viz.plot_above_threshold"><code class="name flex">
<span>def <span class="ident">plot_above_threshold</span></span>(<span>x1, y1, b1, x2, y2, b2, ax, color, lsty)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_above_threshold(x1, y1, b1, x2, y2, b2, ax, color, lsty):
    
    sl1 = (y2 - y1)/(x2 - x1)
    sl2 = (b2 - b1)/(x2 - x1)
    if y1 &gt;= b1 and y2 &gt;= b2:
        ax.plot([x1, x2], [y1, y2], linestyle=lsty, color=color, alpha=1)
    elif y1 &lt; b1 and y2 &lt; b2:
        ax.plot([x1, x2], [y1, y2], linestyle=lsty, color=color, alpha=.1) 
    elif y1 &gt;= b1 and y2 &lt; b2:
        crosspoint_x, crosspoint_y = x1 + (y1 - b1)/(sl2 - sl1), y1 + sl1 * (y1 - b1)/(sl2 - sl1)        
        ax.plot([x1, crosspoint_x], [y1, crosspoint_y], linestyle=lsty, color=color, alpha=1)
        ax.plot([crosspoint_x, x2], [crosspoint_y, y2], linestyle=lsty, color=color, alpha=.1)
    elif y1 &lt; b1 and y2 &gt;= b2:
        crosspoint_x, crosspoint_y = x1 + (y1 - b1)/(sl2 - sl1), y1 + sl1 * (y1 - b1)/(sl2 - sl1)        
        ax.plot([x1, crosspoint_x], [y1, crosspoint_y], linestyle=lsty, color=color, alpha=.1)
        ax.plot([crosspoint_x, x2], [crosspoint_y, y2], linestyle=lsty, color=color, alpha=1) </code></pre>
</details>
</dd>
<dt id="src.viz.plot_background"><code class="name flex">
<span>def <span class="ident">plot_background</span></span>(<span>interval, bg, trace, color, ax)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_background(interval, bg, trace, color, ax):
    ax.fill_between(interval * np.arange(len(bg)), 
                                        [0] * len(bg),
                                        2 * np.array(bg), 
                                        alpha=.1,
                                        color=color) 
                        
    x, y, lt = np.arange(len(trace)), np.array(trace), len(trace)
    #ax.plot(interval * x, y, linestyle=&#39;--&#39;, color=cr, alpha=.2)
    bg = 2 * np.array(bg)
    for f in range(lt - 1):
        lsty = &#39;--&#39; if f &lt; 5 or f &gt;= lt - 5 else &#39;-&#39;
        plot_above_threshold(x1=interval*x[f], 
                             y1=y[f], 
                                                 b1=bg[f], 
                                                 x2=interval*x[f+1], 
                                                 y2=y[f+1], 
                                                 b2=bg[f+1], 
                                                 ax=ax, 
                                                 color=color,
                                                 lsty=lsty)</code></pre>
</details>
</dd>
<dt id="src.viz.plot_confusion_matrix"><code class="name flex">
<span>def <span class="ident">plot_confusion_matrix</span></span>(<span>y_true, y_pred, classes, normalize=False, title=None, cmap=&lt;matplotlib.colors.LinearSegmentedColormap object&gt;)</span>
</code></dt>
<dd>
<section class="desc"><p>This function prints and plots the confusion matrix.
Normalization can be applied by setting <code>normalize=True</code>.
Params</p>
<hr>
<dl>
<dt><strong><code>classes</code></strong> :&ensp;<code>np.ndarray</code>(<code>Str</code>)</dt>
<dd>classes=np.array(['aux-', 'aux+'])</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_confusion_matrix(y_true, y_pred, classes,
                          normalize=False,
                          title=None,
                          cmap=plt.cm.Blues):
    &#34;&#34;&#34;
    This function prints and plots the confusion matrix.
    Normalization can be applied by setting `normalize=True`.
    Params
    ------
    classes: np.ndarray(Str)
        classes=np.array([&#39;aux-&#39;, &#39;aux+&#39;])
    &#34;&#34;&#34;
    plt.figure(dpi=300)
    if not title:
        if normalize:
            title = &#39;Normalized confusion matrix&#39;
        else:
            title = &#39;Confusion matrix, without normalization&#39;

    # Compute confusion matrix
    cm = metrics.confusion_matrix(y_true, y_pred)
    # Only use the labels that appear in the data
    classes = classes[unique_labels(y_true.astype(np.int), y_pred.astype(np.int))]
    if normalize:
        cm = cm.astype(&#39;float&#39;) / cm.sum(axis=1)[:, np.newaxis]

    #     fig, ax = plt.subplots()
    im = plt.imshow(cm, interpolation=&#39;nearest&#39;, cmap=cmap)
    ax = plt.gca()
    #     ax.figure.colorbar(im, ax=ax)
    # We want to show all ticks...
    ax.set(xticks=np.arange(cm.shape[1]),
           yticks=np.arange(cm.shape[0]),
           # ... and label them with the respective list entries
           xticklabels=classes, yticklabels=classes,
           #            title=title,
           ylabel=&#39;True label&#39;,
           xlabel=&#39;Predicted label&#39;)

    # Rotate the tick labels and set their alignment.
    plt.setp(ax.get_xticklabels(), rotation=45, ha=&#34;right&#34;,
             rotation_mode=&#34;anchor&#34;)

    # Loop over data dimensions and create text annotations.
    fmt = &#39;.2f&#39; if normalize else &#39;d&#39;
    thresh = cm.max() / 2.
    for i in range(cm.shape[0]):
        for j in range(cm.shape[1]):
            ax.text(j, i, format(cm[i, j], fmt),
                    ha=&#34;center&#34;, va=&#34;center&#34;,
                    color=&#34;white&#34; if cm[i, j] &gt; thresh else &#34;black&#34;)
    return ax</code></pre>
</details>
</dd>
<dt id="src.viz.plot_curves"><code class="name flex">
<span>def <span class="ident">plot_curves</span></span>(<span>df, extra_key=None, extra_key_label=None, hline=True, R=5, C=8, xlim=None, fig=None, ylim_constant=False, background=False, ylim_cla=None, ylim_aux=None, ylim_dyn=None, xlim_constant=True, legend=True, plot_x=True, yticks=None, yticklabels=None, num_axes=3, show_track_pid=False, axes_invisible=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Plot time-series curves from df</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_curves(df, extra_key=None, extra_key_label=None,
                hline=True, R=5, C=8,
                xlim=None,
                fig=None, ylim_constant=False, background=False, ylim_cla=None,
                ylim_aux=None, ylim_dyn=None,
                xlim_constant=True, legend=True, plot_x=True,
                yticks=None, yticklabels=None, num_axes=3, show_track_pid=False,
                axes_invisible=False):
    &#39;&#39;&#39;Plot time-series curves from df
    &#39;&#39;&#39;
    DIFF = 0
    if fig is None:
        plt.figure(figsize=(16, 10), dpi=200, facecolor=&#39;white&#39;)
    lifetime_max = np.max(df.lifetime.values[:R * C])
    df = df.iloc[range(R * C)]
    for i in range(R * C):
        if i &lt; df.shape[0]:
            ax = plt.subplot(R, C, i + 1)
            row = df.iloc[i]
            if &#39;1.5s&#39; in row[&#39;cell_num&#39;]:
                interval = 1.5
            else:
                interval = 1
                
            if num_axes == 1:
                if plot_x:
                    plt.plot(interval * np.arange(len(row.X_extended)), np.array(row.X_extended) + DIFF, linestyle=&#39;--&#39;, color=cr)
                    plt.plot(interval * np.arange(len(row.Y_extended)), np.array(row.Y_extended) + DIFF, linestyle=&#39;--&#39;, color=cg)
                    plt.plot(interval * np.arange(5, len(row.X_extended)-5), np.array(row.X_extended)[5:(-5)] + DIFF, color=cr, label=&#39;Clathrin&#39;)
                    plt.plot(interval * np.arange(5, len(row.Y_extended)-5), np.array(row.Y_extended)[5:(-5)] + DIFF, color=cg, label=&#39;Auxilin&#39;)
                    #plt.plot(interval * np.arange(5), np.array(row.X_extended)[-5:] + DIFF, linestyle=&#39;--&#39;, color=cr, label=&#39;Clathrin&#39;)
                    #plt.plot(interval * np.arange(5), np.array(row.Y_extended)[-5:] + DIFF, linestyle=&#39;--&#39;, color=cg, label=&#39;Auxilin&#39;) 
                if background:
                    ax.plot(interval * np.arange(len(row.X_extended)), np.array(row.X_c_extended), 
                        color=cr, linewidth=.8)                
                ax.fill_between(interval * np.arange(len(row.X_extended)),
                                 np.array(row.X_extended) - np.array(row.X_std_extended),
                                 np.array(row.X_extended) + np.array(row.X_std_extended),
                                 alpha=.2,
                                 color=cr
                                 )                    
                if hline:
                    plt.axhline(642.3754691658837, color=&#39;gray&#39;, alpha=0.5)
                if extra_key is not None:
                    if extra_key_label is None:
                        if extra_key == &#39;Z&#39;:
                            extra_key_label = &#39;Dynamin&#39;
                        else:
                            extra_key_label = extra_key
                    plt.plot(interval * np.arange(len(row[extra_key])), np.array(row[extra_key]) + DIFF, linestyle=&#39;--&#39;, color=&#39;gray&#39;)
                    plt.plot(interval * np.arange(5, len(row[extra_key])-5), np.array(row[extra_key])[5:(-5)] + DIFF, color=&#39;gray&#39;, label=extra_key_label)
                if xlim_constant:
                    if xlim is None:
                        plt.xlim([-1, lifetime_max + 1])
                    else:
                        print(xlim)
                        plt.xlim(xlim)
                        
                if ylim_constant:
                    if ylim is None:
                        plt.ylim([-10, max(max(df.X_max), max(df.Y_max)) + 1])
                    else:
                        plt.ylim(ylim[0] + DIFF, ylim[1] + DIFF)
                if yticks is not None:
                        plt.yticks(yticks, labels=yticklabels)
                    
            else:
                ax.spines[&#39;right&#39;].set_visible(True)
                twin1 = ax.twinx()
                if num_axes == 3:
                    twin2 = ax.twinx()
                    twin2.spines[&#39;right&#39;].set_visible(True)
                    twin2.spines[&#39;right&#39;].set_position((&#34;axes&#34;, 1.2))
                else:
                    twin2 = twin1
                if show_track_pid:
                    ax.text(.5, .9, f&#39;{row.pid}&#39;, # row.pid
                            horizontalalignment=&#39;right&#39;,
                            transform=ax.transAxes)                    

                if plot_x:
                    p1, = ax.plot(interval * np.arange(len(row.X_extended)), np.array(row.X_extended) + DIFF, linestyle=&#39;--&#39;, color=cr, alpha=.1)
                    if i == 0:
                        ax.text(x=interval * len(row.X_extended),
                            y=np.array(row.X_extended)[-1],
                            s=&#39;CLTA-TagRFP&#39;,
                            color=cr,
                            size=8)
                    if background:
                        plot_background(interval, row.X_sigma_extended, row.X_extended, color=cr, ax=ax)
                               
                    else:
                        ax.plot(interval * np.arange(5, len(row.X_extended)-5), np.array(row.X_extended)[5:(-5)] + DIFF, color=cr)  
                    if i == 0 and legend:
                        dvu.line_legend()                        
                    ax.fill_between(interval * np.arange(len(row.X_extended)),
                                     np.array(row.X_extended) - np.array(row.X_std_extended),
                                     np.array(row.X_extended) + np.array(row.X_std_extended),
                                     alpha=.2,
                                     color=cr
                                     )  

                    
                    p2, = twin1.plot(interval * np.arange(len(row.Y_extended)), np.array(row.Y_extended) + DIFF, linestyle=&#39;--&#39;, color=cg, alpha=.1)
                    
                    if background:
                        plot_background(interval, row.Y_sigma_extended, row.Y_extended, color=cg, ax=twin1
                                       )
                               
                    else:
                        twin1.plot(interval * np.arange(5, len(row.Y_extended)-5), np.array(row.Y_extended)[5:(-5)] + DIFF, color=cg, label=&#39;EGFP-Aux1-GAK-F6&#39;)                     
                    if i == 0 and legend:
                        dvu.line_legend()                                     
                    twin1.fill_between(interval * np.arange(len(row.Y_extended)),
                                     np.array(row.Y_extended) - np.array(row.Y_std_extended),
                                     np.array(row.Y_extended) + np.array(row.Y_std_extended),
                                     alpha=.2,
                                     color=cg
                                     )  
                    if i == 0:
                        twin1.text(x=interval * len(row.Y_extended),
                              y=np.array(row.Y_extended)[-1],
                              s=&#39;EGFP-Aux1-GAK-F6&#39;,
                              color=cg,
                              size=8)                    
                    #plt.plot(interval * np.arange(5), np.array(row.X_extended)[-5:] + DIFF, linestyle=&#39;--&#39;, color=cr, label=&#39;Clathrin&#39;)
                    #plt.plot(interval * np.arange(5), np.array(row.Y_extended)[-5:] + DIFF, linestyle=&#39;--&#39;, color=cg, label=&#39;Auxilin&#39;) 
                    if hline:
                        ax.axhline(642.3754691658837, color=&#39;gray&#39;, alpha=0.5)
                if extra_key is not None:
                    if extra_key_label is None:
                        if extra_key == &#39;Z&#39;:
                            extra_key_label = &#39;Dynamin&#39;
                        else:
                            extra_key_label = extra_key
                    p3, = twin2.plot(interval * np.arange(len(row.Z_extended)), np.array(row.Z_extended) + DIFF, linestyle=&#39;--&#39;, color=&#39;gray&#39;, alpha=.1)
                    
                    if background:
                        plot_background(interval, row.Z_sigma_extended, row.Z_extended, color=&#39;gray&#39;, ax=twin2)
                               
                    else:
                        twin2.plot(interval * np.arange(5, len(row.Z_extended)-5), np.array(row.Z_extended)[5:(-5)] + DIFF, color=&#39;gray&#39;)
                    twin2.fill_between(interval * np.arange(len(row.Z_extended)),
                                     np.array(row.Z_extended) - np.array(row.Z_std_extended),
                                     np.array(row.Z_extended) + np.array(row.Z_std_extended),
                                     alpha=.1,
                                     color=&#39;gray&#39;
                                     )
                    if i == 0:
                        twin2.text(x=interval * len(row.Z_extended),
                              y=np.array(row.Z_extended)[-1]-500,
                              s=&#39;Dyn2-Halo-E1-JF646&#39;,
                              color=&#39;gray&#39;,
                              size=8)                    
                    #if i == 0 and legend:
                    #    dvu.line_legend()                    
                tkw = dict(size=4, width=1.5)
                ax.spines[&#39;right&#39;].set_color(cg)
                ax.tick_params(axis=&#39;y&#39;, colors=cr, labelsize=6, **tkw)
                twin1.spines[&#39;left&#39;].set_color(cr)
                ax.spines[&#39;left&#39;].set_color(cr)
                #twin1.spines[&#39;left&#39;].set_color(cg)
                if num_axes == 3:
                    twin2.spines[&#39;left&#39;].set_color(cr)
                    twin2.spines[&#39;right&#39;].set_color(p3.get_color())  
                    twin2.tick_params(axis=&#39;y&#39;, colors=p3.get_color(), labelsize=6, **tkw)
                if ylim_constant:
                    ax.set_ylim(ylim_cla)
                    twin1.set_ylim(ylim_aux)
                    twin2.set_ylim(ylim_dyn)
                else:
                    #p1_ylim = ax.get_ylim()
                    p2_ylim = twin1.get_ylim()                    
                    p3_ylim = twin2.get_ylim()
                    ylim_min = min(p2_ylim[0], p3_ylim[0])
                    twin1.set_ylim((ylim_min, 2*p2_ylim[1]))
                    twin2.set_ylim((ylim_min, 3*p3_ylim[1]))   
                
                p1_ylim = ax.get_ylim() 
                ax.set_ylim((- 2 * p1_ylim[1], p1_ylim[1])) 
                
                p2_ylim = twin1.get_ylim() 
                twin1.set_ylim((- 0.5 * p2_ylim[1], p2_ylim[1])) 
                
                #p3_ylim = twin2.get_ylim() 
                #twin1.set_ylim((- 0.5 * p3_ylim[1], p3_ylim[1]))  
                
                twin1.tick_params(axis=&#39;y&#39;, colors=cg, labelsize=6, **tkw)
                
                ax.tick_params(axis=&#39;x&#39;, **tkw)
                yticks = ax.get_yticks()
                #if len(yticks) &gt; 5:
                ax.set_yticks([yt for yt in yticks if yt &gt;= 0])
                
                yticks = twin1.get_yticks()
                #if len(yticks) &gt; 5:
                twin1.set_yticks(yticks[np.arange(1, len(yticks), 2)])
                if num_axes == 3:
                    yticks = twin2.get_yticks()
                    if len(yticks) &gt; 5:
                        twin2.set_yticks(yticks[np.arange(1, len(yticks), 2)])                   
                if xlim_constant:
                    if xlim is None:
                        plt.xlim([-1, lifetime_max + 16])
                    else:
                        print(xlim)
                        plt.xlim(xlim)
                
                if axes_invisible:
                    ax.yaxis.set_visible(False)
                    ax.xaxis.set_visible(False)
                    twin1.yaxis.set_visible(False)
                    twin1.spines[&#39;left&#39;].set_color(&#39;w&#39;)
                    twin2.spines[&#39;left&#39;].set_color(&#39;w&#39;)
                    twin2.yaxis.set_visible(False)
                    twin1.spines[&#39;right&#39;].set_color(&#39;w&#39;)
                    twin2.spines[&#39;right&#39;].set_color(&#39;w&#39;)
                
                                
            #plt.yscale(&#39;log&#39;)                  
            

    #     plt.axi(&#39;off&#39;)

            
#         plt.legend()

    plt.tight_layout()
    if fig is None:
        plt.show()        </code></pre>
</details>
</dd>
<dt id="src.viz.plot_decision_boundary"><code class="name flex">
<span>def <span class="ident">plot_decision_boundary</span></span>(<span>X_col, Y_col, m, df, norms, num_pts=100)</span>
</code></dt>
<dd>
<section class="desc"><p>still not finished&hellip;</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_decision_boundary(X_col, Y_col, m, df, norms, num_pts=100):
    &#39;&#39;&#39;still not finished...
    &#39;&#39;&#39;
    x = df[X_col]
    y = df[Y_col]
    x = np.linspace(x.min(), x.max(), num_pts)
    y = np.linspace(y.min(), y.max(), num_pts)

    # normalize
    xv, yv = np.meshgrid(x, y, indexing=&#39;ij&#39;)
    x = xv.flatten()
    y = yv.flatten()
    x = (x - norms[X_col][&#39;mu&#39;]) / (norms[X_col][&#39;std&#39;])
    y = (y - norms[Y_col][&#39;mu&#39;]) / (norms[Y_col][&#39;std&#39;])

    X = np.hstack((x, y)).reshape(-1, 2)
    print(X.shape)

    X = df[results_individual[&#39;feat_names_selected&#39;]]

    preds = m.predict(X)</code></pre>
</details>
</dd>
<dt id="src.viz.plot_example"><code class="name flex">
<span>def <span class="ident">plot_example</span></span>(<span>ex)</span>
</code></dt>
<dd>
<section class="desc"><p>ex - row of the dataframe</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_example(ex):
    &#39;&#39;&#39;ex - row of the dataframe
    &#39;&#39;&#39;
    plt.figure(dpi=200)
    plt.plot(ex[&#39;X&#39;], color=&#39;red&#39;, label=&#39;clathrin&#39;)
    plt.plot(ex[&#39;Y&#39;], color=&#39;green&#39;, label=&#39;auxilin&#39;)
    plt.xlabel(&#39;Time&#39;)
    plt.ylabel(&#39;Amplitude&#39;)
    plt.legend()</code></pre>
</details>
</dd>
<dt id="src.viz.plot_kymographs"><code class="name flex">
<span>def <span class="ident">plot_kymographs</span></span>(<span>df, pids, add_px=2)</span>
</code></dt>
<dd>
<section class="desc"><p>plot kymographs of dynamin traces </p>
<h2 id="params">Params:</h2>
<p>df: pd.DataFrame
dataframe</p>
<p>pids: list
list of pids to plot</p>
<p>add_px: int
number of additional pixels in each direction
add_px=1 means 3<em>3 pixels around the center, add_px=2 means 5</em>5, etc.</p>
<h2 id="returns">Returns:</h2>
<p>cla_traces: np.array
clathrin traces from raw images
aux_traces: np.array
auxilin traces from raw images
rgb_image: 3d np.array
3d array (RGB values) of kymographs</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_kymographs(df, pids, add_px=2):
    
    &#34;&#34;&#34;
    plot kymographs of dynamin traces 
    
    Params:
    ------
    df: pd.DataFrame
        dataframe
    
    pids: list
        list of pids to plot
        
    add_px: int
        number of additional pixels in each direction
        add_px=1 means 3*3 pixels around the center, add_px=2 means 5*5, etc.
        
    Returns:
    ------
    cla_traces: np.array
        clathrin traces from raw images
    aux_traces: np.array
        auxilin traces from raw images
    rgb_image: 3d np.array
        3d array (RGB values) of kymographs
    &#34;&#34;&#34;
    
    indices = np.array([np.where(df.pid.values == pid)[0][0] for pid in pids])
    df = df.iloc[indices]
    cells = set(df.cell_num.values)
    raw_videos = get_all_dynamin_videos(cells)
    viridis = cm.get_cmap(&#39;viridis&#39;, 12)
    reds = cm.get_cmap(&#39;Reds&#39;, 12) # red palette for clathrin
    greens = cm.get_cmap(&#39;Greens&#39;, 12) # green palette for auxilin
    
    lmax = max([len(df.x_pos_seq.iloc[i]) for i in range(len(df))]) + 2
    width = 2 * add_px + 1
    cla_traces, aux_traces = {}, {}
    
    for i in range(len(df)):
        cla_traces[i], aux_traces[i] = np.zeros((lmax, width)), np.zeros((lmax, width))
        #xmean = X[df.cell_num.iloc[i]].mean()
        cell_num = df.cell_num.iloc[i]
        x_pos, y_pos = df.x_pos_seq.iloc[i], df.y_pos_seq.iloc[i]
        t, lt = df.t.iloc[i], min(len(x_pos), len(y_pos))        
        
        for k in range(-add_px, add_px + 1):
            for j in range(lt):
                video = raw_videos[cell_num][&#39;cla&#39;]
                cla_traces[i][j, k + add_px] = max(video[int(t/1.5) + j, \
                                                      range(int(y_pos[j]) - 0, int(y_pos[j]) + 0 + 1), \
                                                      int(x_pos[j] + k)])
                vmin, vmax = video[int(t/1.5) + j,:,:].min(), video[int(t/1.5) + j,:,:].max()
                cla_traces[i][j, k + add_px] = (cla_traces[i][j, k + add_px] - vmin)/(vmax - vmin)
                
                video = raw_videos[cell_num][&#39;aux&#39;]
                aux_traces[i][j, k + add_px] = max(video[int(t/1.5) + j, \
                                                      range(int(y_pos[j]) - 0, int(y_pos[j]) + 0 + 1), \
                                                      int(x_pos[j] + k)])
                vmin, vmax = video[int(t/1.5) + j,:,:].min(), video[int(t/1.5) + j,:,:].max()
                aux_traces[i][j, k + add_px] = (aux_traces[i][j, k + add_px] - vmin)/(vmax - vmin)                
    
    ncol = 3 * width * len(df)
    cla_sparse = np.zeros((lmax, ncol))
    aux_sparse = np.zeros((lmax, ncol))
    for i in range(len(df)):
        start_index = 3 * width * i
        cla_sparse[:, (start_index):(start_index + width)] = cla_traces[i]
        aux_sparse[:, (start_index + width):(start_index + 2 * width)] = aux_traces[i]
    
    rgb_image = np.array([[list(reds(cla_sparse[i][j])[:3])
                      #[1, 1 - cla_sparse[i][j], 1 - cla_sparse[i][j]] \
                      if 0 &lt; cla_sparse[i][j] &lt; 1 \
                      else \
                      list(greens(aux_sparse[i][j])[:3]) \
                      #[1 - aux_sparse[i][j], 1, 1 - aux_sparse[i][j]] \
                      if 0 &lt; aux_sparse[i][j] &lt; 1 \
                      #else list(viridis(np.random.choice(background, 1)[0])[:3])\
                      else (1, 1, 1)
                      for i in range(lmax)] \
                      for j in range(ncol)])
    #cla_sparse = np.transpose(cla_sparse)
    #aux_sparse = np.transpose(aux_sparse)
    return cla_traces, aux_traces, rgb_image</code></pre>
</details>
</dd>
<dt id="src.viz.plot_pcs"><code class="name flex">
<span>def <span class="ident">plot_pcs</span></span>(<span>pca, X)</span>
</code></dt>
<dd>
<section class="desc"><p>Pretty plot of pcs with explained var bars
Params</p>
<hr>
<dl>
<dt><strong><code>pca</code></strong> :&ensp;<code>sklearn</code> <code>PCA</code> <code>class</code> <code>after</code> <code>being</code> <code>fitted</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_pcs(pca, X):
    &#39;&#39;&#39;Pretty plot of pcs with explained var bars
    Params
    ------
    pca: sklearn PCA class after being fitted
    &#39;&#39;&#39;
    plt.figure(figsize=(6, 9), dpi=200)

    # extract out relevant pars
    comps = pca.components_.transpose()
    var_norm = pca.explained_variance_ / np.sum(pca.explained_variance_) * 100

    # create a 2 X 2 grid 
    gs = grd.GridSpec(2, 2, height_ratios=[2, 10],
                      width_ratios=[12, 1], wspace=0.1, hspace=0)

    # plot explained variance
    ax2 = plt.subplot(gs[0])
    ax2.bar(np.arange(0, comps.shape[1]), var_norm,
            color=&#39;gray&#39;, width=0.8)
    plt.title(&#39;Explained variance (%)&#39;)
    ax2.spines[&#39;right&#39;].set_visible(False)
    ax2.spines[&#39;top&#39;].set_visible(False)
    ax2.yaxis.set_ticks_position(&#39;left&#39;)
    ax2.set_yticks([0, max(var_norm)])
    plt.xlim((-0.5, comps.shape[1] - 0.5))

    # plot pcs
    ax = plt.subplot(gs[2])
    vmaxabs = np.max(np.abs(comps))
    p = ax.imshow(comps, interpolation=&#39;None&#39;, aspect=&#39;auto&#39;,
                  cmap=sns.diverging_palette(10, 240, as_cmap=True, center=&#39;light&#39;),
                  vmin=-vmaxabs, vmax=vmaxabs)  # center at 0
    plt.xlabel(&#39;PCA component number&#39;)
    ax.set_yticklabels(list(X))
    ax.set_yticks(range(len(list(X))))

    # make colorbar
    colorAx = plt.subplot(gs[3])
    cb = plt.colorbar(p, cax=colorAx)
    plt.show()</code></pre>
</details>
</dd>
<dt id="src.viz.print_metadata"><code class="name flex">
<span>def <span class="ident">print_metadata</span></span>(<span>acc=None, metadata_file='/accounts/projects/vision/chandan/auxilin-prediction/src/../data/processed/metadata_clath_aux+gak_a7d2.pkl')</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_metadata(acc=None, metadata_file=oj(config.DIR_PROCESSED, &#39;metadata_clath_aux+gak_a7d2.pkl&#39;)):
    m = pkl.load(open(metadata_file, &#39;rb&#39;))

    print(
        f&#39;valid:\t\t{m[&#34;num_aux_pos_valid&#34;]:&gt;4.0f} aux+ / {m[&#34;num_tracks_valid&#34;]:&gt;4.0f} ({m[&#34;num_aux_pos_valid&#34;] / m[&#34;num_tracks_valid&#34;]:.3f})&#39;)
    print(&#39;----------------------------------------&#39;)
    print(f&#39;hotspots:\t{m[&#34;num_hotspots_valid&#34;]:&gt;4.0f} aux+ / {m[&#34;num_hotspots_valid&#34;]:&gt;4.0f}&#39;)
    print(
        f&#39;short:\t\t{m[&#34;num_short&#34;] - m[&#34;num_short&#34;] * m[&#34;acc_short&#34;]:&gt;4.0f} aux+ / {m[&#34;num_short&#34;]:&gt;4.0f} ({m[&#34;acc_short&#34;]:.3f})&#39;)
    print(f&#39;long:\t\t{m[&#34;num_long&#34;] * m[&#34;acc_long&#34;]:&gt;4.0f} aux+ / {m[&#34;num_long&#34;]:&gt;4.0f} ({m[&#34;acc_long&#34;]:.3f})&#39;)
    print(
        f&#39;hard:\t\t{m[&#34;num_aux_pos_hard&#34;]:&gt;4.0f} aux+ / {m[&#34;num_tracks_hard&#34;]:&gt;4.0f} ({m[&#34;num_aux_pos_hard&#34;] / m[&#34;num_tracks_hard&#34;]:.3f})&#39;)

    if acc is not None:
        print(&#39;----------------------------------------&#39;)
        print(f&#39;hard acc:\t\t\t  {acc:.3f}&#39;)
        num_eval = m[&#34;num_tracks_valid&#34;] - m[&#34;num_hotspots_valid&#34;]
    #         print(
    #             f&#39;total acc (no hotspots):\t  {(m[&#34;num_short&#34;] * m[&#34;acc_short&#34;] + m[&#34;num_long&#34;] * m[&#34;acc_long&#34;] + acc * m[&#34;num_tracks_hard&#34;]) / num_eval:.3f}&#39;)
    print(&#39;\nlifetime threshes&#39;, m[&#39;thresh_short&#39;], m[&#39;thresh_long&#39;])</code></pre>
</details>
</dd>
<dt id="src.viz.savefig"><code class="name flex">
<span>def <span class="ident">savefig</span></span>(<span>s, png=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def savefig(s: str, png=False):
#     plt.tight_layout()
    plt.savefig(oj(DIR_FIGS, &#39;fig_&#39; + s + &#39;.pdf&#39;), bbox_inches=&#39;tight&#39;)
    if png:
        plt.savefig(oj(DIR_FIGS, &#39;fig_&#39; + s + &#39;.png&#39;), dpi=300, bbox_inches=&#39;tight&#39;)</code></pre>
</details>
</dd>
<dt id="src.viz.viz_biggest_errs"><code class="name flex">
<span>def <span class="ident">viz_biggest_errs</span></span>(<span>df, idxs_cv, idxs, Y_test, preds, preds_proba, num_to_plot=20, aux_thresh=642, show_track_num=True, show_track_pid=False, sort_by_residuals=True, width_mult=3, plot_x=True, plot_y=True, plot_z=False, plot_axhline=True, xlim_constant=True, ylim=None, yticks=None, yticklabels=None, lifetime_max=None, text_labels=False, text_label_size=25)</span>
</code></dt>
<dd>
<section class="desc"><p>Visualize X and Y where the top examples are the most wrong / least confident
Params</p>
<hr>
<dl>
<dt><strong><code>idxs_cv</code></strong> :&ensp;<code>integer</code> <code>ndarray</code></dt>
<dd>which idxs are not part of the test set (usually just 0, 1, 2, &hellip;)</dd>
<dt><strong><code>idxs</code></strong> :&ensp;<code>boolean</code> <code>ndarray</code></dt>
<dd>subset of points to plot</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def viz_biggest_errs(df, idxs_cv, idxs, Y_test, preds, preds_proba,
                     num_to_plot=20,
                     aux_thresh=642,
                     show_track_num=True,
                     show_track_pid=False,
                     sort_by_residuals=True,
                     width_mult=3,
                     plot_x=True,
                     plot_y=True,
                     plot_z=False,
                     plot_axhline=True,
                     xlim_constant=True,
                     ylim: tuple=None,
                     yticks=None,
                     yticklabels=None,
                     lifetime_max=None,
                     text_labels=False,
                     text_label_size=25):
    &#39;&#39;&#39;Visualize X and Y where the top examples are the most wrong / least confident
    Params
    ------
    idxs_cv: integer ndarray
        which idxs are not part of the test set (usually just 0, 1, 2, ...)
    idxs: boolean ndarray
        subset of points to plot
    
    &#39;&#39;&#39;
    DIFF = 0 # use this to ensure values are all positive
    
    # deal with idxs
    if idxs is not None:
        Y_test = Y_test[idxs]
        preds = preds[idxs]
        preds_proba = preds_proba[idxs]
        if idxs_cv is None:
            idxs_cv = np.arange(df.shape[0])
        df = df.iloc[idxs_cv][idxs]
    
    # get args to sort by
    if sort_by_residuals:
        residuals = np.abs(Y_test - preds_proba)
        args = np.argsort(residuals)[::-1]
        dft = df.iloc[args]
    else:
        dft = df
    if lifetime_max is None:
        lifetime_max = np.max(dft.lifetime.values)
    if num_to_plot is None:
        num_to_plot = dft.shape[0]
    R = int(np.sqrt(num_to_plot))
    C = num_to_plot // R  # + 1
    plt.figure(figsize=(C * width_mult, R * 2.5), dpi=200)

    i = 0
    for r in range(R):
        for c in range(C):
            if i &lt; dft.shape[0]:
                row = dft.iloc[i]
                ax = plt.subplot(R, C, i + 1)
                # show nums on tracks
                if show_track_num:
                    ax.text(.5, .9, f&#39;{i}&#39;, # row.pid
                            horizontalalignment=&#39;right&#39;,
                            transform=ax.transAxes)
                elif show_track_pid:
                    ax.text(.5, .9, f&#39;{row.pid}&#39;, # row.pid
                            horizontalalignment=&#39;right&#39;,
                            transform=ax.transAxes)

#                 plt.axis(&#39;off&#39;)
                if &#39;1.5s&#39; in row[&#39;cell_num&#39;]:
                    interval = 1.5
                else:
                    interval = 1
                if plot_x:
                    plt.plot(interval * np.arange(len(row[&#34;X&#34;])), np.array(row[&#34;X&#34;]) + DIFF, color=cr, label=&#39;clath&#39;, lw=2) # could do X_extended
                if plot_y:
                    plt.plot(interval * np.arange(len(row[&#34;Y&#34;])), np.array(row[&#34;Y&#34;]) + DIFF, color=cg, label=&#39;aux&#39;, lw=2)
                if plot_z:
                    plt.plot(interval * np.arange(len(row[&#34;Z&#34;])), np.array(row[&#34;Z&#34;]) + DIFF, color=&#39;gray&#39;, label=&#39;dyn&#39;)               
                    
                if xlim_constant:
                    plt.xlim([-1, lifetime_max])
                
                if plot_axhline:
                    plt.axhline(aux_thresh, color=&#39;gray&#39;, alpha=0.5, lw=2)
                
                #plt.yscale(&#39;log&#39;)
                if ylim is not None:
                    plt.ylim((ylim[0] + DIFF, ylim[1] + DIFF))
                    
                if not r == R - 1:
                    plt.xticks([])
                if not c == 0:
                    plt.yticks([])     
                elif yticks is not None:
                    plt.yticks(yticks, labels=yticklabels)

                i += 1
                
    if text_labels:
        plt.text(len(row[&#34;X&#34;]), row[&#34;X&#34;][-1] + DIFF, &#39;Clathrin&#39;, color=cr, 
                 fontsize=text_label_size, fontweight=&#39;bold&#39;)
        plt.text(len(row[&#34;Y&#34;]), row[&#34;Y&#34;][-1] + DIFF, &#39;Auxilin&#39;, color=cg, 
                 fontsize=text_label_size, fontweight=&#39;bold&#39;)
        if plot_z:
            plt.text(len(row[&#34;Z&#34;]), row[&#34;Z&#34;][-1] + DIFF, &#39;Dynamin&#39;, 
                     fontsize=text_label_size, color=&#39;gray&#39;, fontweight=&#39;bold&#39;)
    plt.tight_layout()
    return dft</code></pre>
</details>
</dd>
<dt id="src.viz.viz_errs_1d"><code class="name flex">
<span>def <span class="ident">viz_errs_1d</span></span>(<span>X_test, preds, preds_proba, Y_test, norms, key='lifetime')</span>
</code></dt>
<dd>
<section class="desc"><p>visualize errs based on lifetime</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def viz_errs_1d(X_test, preds, preds_proba, Y_test, norms, key=&#39;lifetime&#39;):
    &#39;&#39;&#39;visualize errs based on lifetime
    &#39;&#39;&#39;
    plt.figure(dpi=200)
    correct_idxs = preds == Y_test
    lifetime = X_test[key] * norms[key][&#39;std&#39;] + norms[key][&#39;mu&#39;]

    plt.plot(lifetime[(preds == Y_test) &amp; (preds == 1)], preds_proba[(preds == Y_test) &amp; (preds == 1)], &#39;o&#39;,
             color=cb, alpha=0.5, label=&#39;true pos&#39;)
    plt.plot(lifetime[(preds == Y_test) &amp; (preds == 0)], preds_proba[(preds == Y_test) &amp; (preds == 0)], &#39;x&#39;,
             color=cb, alpha=0.5, label=&#39;true neg&#39;)
    plt.plot(lifetime[preds &gt; Y_test], preds_proba[preds &gt; Y_test], &#39;o&#39;, color=cr, alpha=0.5, label=&#39;false pos&#39;)
    plt.plot(lifetime[preds &lt; Y_test], preds_proba[preds &lt; Y_test], &#39;x&#39;, color=cr, alpha=0.5, label=&#39;false neg&#39;)
    plt.xlabel(key)
    plt.ylabel(&#39;predicted probability&#39;)
    plt.legend()
    plt.show()</code></pre>
</details>
</dd>
<dt id="src.viz.viz_errs_2d"><code class="name flex">
<span>def <span class="ident">viz_errs_2d</span></span>(<span>df, idxs_test, preds, Y_test, key1='x_pos', key2='y_pos', X=None, plot_correct=True)</span>
</code></dt>
<dd>
<section class="desc"><p>visualize distribution of errs wrt to 2 dimensions</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def viz_errs_2d(df, idxs_test, preds, Y_test, key1=&#39;x_pos&#39;, key2=&#39;y_pos&#39;, X=None, plot_correct=True):
    &#39;&#39;&#39;visualize distribution of errs wrt to 2 dimensions
    &#39;&#39;&#39;
    x_pos = df[key1].iloc[idxs_test]
    y_pos = df[key2].iloc[idxs_test]

    plt.figure(dpi=200)
    ms = 4
    me = 1
    if plot_correct:
        plt.plot(x_pos[(preds == Y_test) &amp; (preds == 1)], y_pos[(preds == Y_test) &amp; (preds == 1)], &#39;o&#39;,
                 color=cb, alpha=0.4, label=&#39;true pos&#39;, ms=ms, markeredgewidth=0)
        plt.plot(x_pos[(preds == Y_test) &amp; (preds == 0)], y_pos[(preds == Y_test) &amp; (preds == 0)], &#39;o&#39;,
                 color=cr, alpha=0.4, label=&#39;true neg&#39;, ms=ms, markeredgewidth=0)
    plt.plot(x_pos[preds &gt; Y_test], y_pos[preds &gt; Y_test], &#39;x&#39;, color=cb,
             alpha=0.4, label=&#39;false pos&#39;, ms=ms, markeredgewidth=1)
    plt.plot(x_pos[preds &lt; Y_test], y_pos[preds &lt; Y_test], &#39;x&#39;, color=cr,
             alpha=0.4, label=&#39;false neg&#39;, ms=ms, markeredgewidth=1)
    plt.legend()
    #     plt.scatter(x_pos, y_pos, c=preds==Y_test, alpha=0.5)
    plt.xlabel(key1)
    plt.ylabel(key2)
    plt.tight_layout()</code></pre>
</details>
</dd>
<dt id="src.viz.viz_errs_outliers_venn"><code class="name flex">
<span>def <span class="ident">viz_errs_outliers_venn</span></span>(<span>X_test, preds, Y_test, num_feats_reduced=5)</span>
</code></dt>
<dd>
<section class="desc"><p>Compare outliers to errors in venn-diagram</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def viz_errs_outliers_venn(X_test, preds, Y_test, num_feats_reduced=5):
    &#39;&#39;&#39;Compare outliers to errors in venn-diagram
    &#39;&#39;&#39;
    feat_names = data.get_feature_names(X_test)
    X_feat = X_test[feat_names]

    if num_feats_reduced is not None:
        pca = decomposition.PCA(n_components=num_feats_reduced)
        X_reduced = pca.fit_transform(X_feat)
    else:
        X_reduced = X_feat

    R, C = 2, 2
    titles = [&#39;isolation forest&#39;, &#39;local outlier factor&#39;, &#39;elliptic envelop&#39;, &#39;one-class svm&#39;]
    plt.figure(figsize=(6, 5), dpi=200)
    for i in range(4):
        plt.subplot(R, C, i + 1)
        plt.title(titles[i])
        if i == 0:
            clf = IsolationForest(n_estimators=10, warm_start=True)
        elif i == 1:
            clf = LocalOutlierFactor(novelty=True)
        elif i == 2:
            clf = EllipticEnvelope()
        elif i == 3:
            clf = OneClassSVM()
        clf.fit(X_reduced)  # fit 10 trees  
        is_outlier = clf.predict(X_reduced) == -1
        is_err = preds != Y_test
        idxs = np.arange(is_outlier.size)
        venn2([set(idxs[is_outlier]), set(idxs[is_err])], set_labels=[&#39;outliers&#39;, &#39;errors&#39;])</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src" href="index.html">src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="src.viz.cumulative_acc_plot_all" href="#src.viz.cumulative_acc_plot_all">cumulative_acc_plot_all</a></code></li>
<li><code><a title="src.viz.cumulative_acc_plot_hard" href="#src.viz.cumulative_acc_plot_hard">cumulative_acc_plot_hard</a></code></li>
<li><code><a title="src.viz.fix_feat_name" href="#src.viz.fix_feat_name">fix_feat_name</a></code></li>
<li><code><a title="src.viz.get_all_dynamin_videos" href="#src.viz.get_all_dynamin_videos">get_all_dynamin_videos</a></code></li>
<li><code><a title="src.viz.get_dynamin_data_videos" href="#src.viz.get_dynamin_data_videos">get_dynamin_data_videos</a></code></li>
<li><code><a title="src.viz.get_videos" href="#src.viz.get_videos">get_videos</a></code></li>
<li><code><a title="src.viz.highlight_max" href="#src.viz.highlight_max">highlight_max</a></code></li>
<li><code><a title="src.viz.jointplot_grouped" href="#src.viz.jointplot_grouped">jointplot_grouped</a></code></li>
<li><code><a title="src.viz.plot_above_threshold" href="#src.viz.plot_above_threshold">plot_above_threshold</a></code></li>
<li><code><a title="src.viz.plot_background" href="#src.viz.plot_background">plot_background</a></code></li>
<li><code><a title="src.viz.plot_confusion_matrix" href="#src.viz.plot_confusion_matrix">plot_confusion_matrix</a></code></li>
<li><code><a title="src.viz.plot_curves" href="#src.viz.plot_curves">plot_curves</a></code></li>
<li><code><a title="src.viz.plot_decision_boundary" href="#src.viz.plot_decision_boundary">plot_decision_boundary</a></code></li>
<li><code><a title="src.viz.plot_example" href="#src.viz.plot_example">plot_example</a></code></li>
<li><code><a title="src.viz.plot_kymographs" href="#src.viz.plot_kymographs">plot_kymographs</a></code></li>
<li><code><a title="src.viz.plot_pcs" href="#src.viz.plot_pcs">plot_pcs</a></code></li>
<li><code><a title="src.viz.print_metadata" href="#src.viz.print_metadata">print_metadata</a></code></li>
<li><code><a title="src.viz.savefig" href="#src.viz.savefig">savefig</a></code></li>
<li><code><a title="src.viz.viz_biggest_errs" href="#src.viz.viz_biggest_errs">viz_biggest_errs</a></code></li>
<li><code><a title="src.viz.viz_errs_1d" href="#src.viz.viz_errs_1d">viz_errs_1d</a></code></li>
<li><code><a title="src.viz.viz_errs_2d" href="#src.viz.viz_errs_2d">viz_errs_2d</a></code></li>
<li><code><a title="src.viz.viz_errs_outliers_venn" href="#src.viz.viz_errs_outliers_venn">viz_errs_outliers_venn</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>